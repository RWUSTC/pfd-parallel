<defun name="pfd_compute">

  <include-structs href="types.xpnet"/>

  <require key="worker" mandatory="true"/>

  <in name="in" type="unsigned int" place="intask"/>
  <in name="options" type="options_type"place="readoptions"/>
  <out name="out" type="unsigned int" place="out"/>

  <net>
    <place name="intask" type="unsigned int"/>
    <place name="computed_status" type="task_status"/>
    <place name="prepared_ssi" type="unsigned int"/>
    <place name="triviality_status" type="task_status"/>
    <place name="prepared_input" type="unsigned int"/>
    <place name="nullstellensatz_done" type="unsigned int"/>
    <place name="short_numerator_done" type="unsigned int"/>
    <place name="algebraic_dependence_done" type="unsigned int"/>
    <place name="numerator_done" type="unsigned int"/>
    <place name="out" type="unsigned int"/>
    <place name="readoptions" type="options_type"/>

    <place name="null_step_name" type="string">
      <token><value>"NSSdecompStep"</value></token>
    </place>
    <place name="short_num_name" type="string">
      <token><value>"shortNumeratorDecompStep"</value></token>
    </place>
    <place name="algebraic_step_name" type="string">
      <token><value>"algDependDecompStep"</value></token>
    </place>
    <place name="numerator_step_name" type="string">
      <token><value>"numeratorDecompStep"</value></token>
    </place>

    <transition name="check_if_already_done">
      <defun>
        <require key="worker" mandatory="true"/>
        <in name="in" type="unsigned int"/>
        <in name="options" type="options_type"/>
        <out name="out" type="task_status"/>

        <module name="singular_parallel_allpfd"
                require_function_unloads_without_rest="false"
                function="check_done
                            ( options
                            , in
                            , out
                            )">
          <cinclude href="interface/singular_pnet-interface.hpp"/>
          <cinclude href="util-generic/dynamic_linking.hpp"/>
          <cinclude href="iostream"/>
          <code><![CDATA[
            //<>
            std::cout << "checking if " << in << " has been precomputed\n";

            unsigned int already_done = RESOLVE_INTERFACE_FUNCTION
              (pfd_already_done)
              ( in, options );
            if (already_done) {
              std::cout << in << " already done!\n";
            } else {
              std::cout << in << " still to be computed.\n";
            }
            out.id = in;
            out.status = already_done;

          ]]></code>
        </module>
      </defun>
      <connect-in port="in" place="intask"/>
      <connect-read port="options" place="readoptions"/>
      <connect-out port="out" place="computed_status"/>
    </transition>

    <transition name="consume_precomputed">
      <defun>
        <require key="worker" mandatory="true"/>
        <in name="in" type="task_status"/>
        <out name="out" type="unsigned int"/>

        <condition>
          ${in.status} :gt: 0U
        </condition>

        <expression>
            ${out} := ${in.id};
        </expression>
      </defun>
      <connect-in port="in" place="computed_status"/>
      <connect-out port="out" place="out"/>
    </transition>

    <transition name="prepare_ssi">
      <defun>
        <require key="worker" mandatory="true"/>
        <in name="in" type="task_status"/>
        <in name="options" type="options_type"/>
        <out name="out" type="unsigned int"/>

        <condition>
          ${in.status} :eq: 0U
        </condition>

        <module name="singular_parallel_allpfd"
                require_function_unloads_without_rest="false"
                function="prepare_ssi
                            ( options
                            , in
                            , out
                            )">
          <cinclude href="interface/singular_pnet-interface.hpp"/>
          <cinclude href="util-generic/dynamic_linking.hpp"/>
          <cinclude href="iostream"/>
          <code><![CDATA[
            std::cout << "Preparing ssi for " << in.id << "\n";

            RESOLVE_INTERFACE_FUNCTION 
              (pfd_prepare_single_entry_fraction)
              ( in.id
              , options);
            std::cout << "Preparing ssi for " << in.id << " done!\n";
            out = in.id;

          ]]></code>
        </module>
      </defun>
      <connect-in port="in" place="computed_status"/>
      <connect-read port="options" place="readoptions"/>
      <connect-out port="out" place="prepared_ssi"/>
    </transition>

    <transition name="check_if_trivial">
      <defun>
        <require key="worker" mandatory="true"/>
        <in name="in" type="unsigned int"/>
        <in name="options" type="options_type"/>
        <out name="out" type="task_status"/>

        <module name="singular_parallel_allpfd"
                require_function_unloads_without_rest="false"
                function="check_triviality
                            ( options
                            , in
                            , out
                            )">
          <cinclude href="interface/singular_pnet-interface.hpp"/>
          <cinclude href="util-generic/dynamic_linking.hpp"/>
          <cinclude href="iostream"/>
          <code><![CDATA[
            std::cout << "checking if " << in << " is trivial\n";

            unsigned int is_trivial = RESOLVE_INTERFACE_FUNCTION 
              (pfd_is_trivial)
              ( in, options );
            if (is_trivial) {
              std::cout << in << " is trivial!\n";
            } else {
              std::cout << in << " is non-trivial.\n";
            }
            out.id = in;
            out.status = is_trivial;

          ]]></code>
        </module>
      </defun>
      <connect-in port="in" place="prepared_ssi"/>
      <connect-read port="options" place="readoptions"/>
      <connect-out port="out" place="triviality_status"/>
    </transition>

    <transition name="consume_trivial">
      <defun>
        <require key="worker" mandatory="true"/>
        <in name="in" type="task_status"/>
        <out name="out" type="unsigned int"/>

        <condition>
          ${in.status} :gt: 0U
        </condition>

        <expression>
            ${out} := ${in.id};
        </expression>
      </defun>
      <connect-in port="in" place="triviality_status"/>
      <connect-out port="out" place="out"/>
    </transition>

    <transition name="prepare_input">
      <defun>
        <require key="worker" mandatory="true"/>
        <in name="in" type="task_status"/>
        <in name="options" type="options_type"/>
        <in name="first_step" type="string"/>
        <out name="out" type="unsigned int"/>

        <condition>
          ${in.status} :eq: 0U
        </condition>

        <module name="singular_parallel_allpfd"
                require_function_unloads_without_rest="false"
                function="prepare_input
                            ( options
                            , in
                            , out
                            , first_step
                            )">
          <cinclude href="interface/singular_pnet-interface.hpp"/>
          <cinclude href="util-generic/dynamic_linking.hpp"/>
          <cinclude href="iostream"/>
          <code><![CDATA[
          /*<>*/

            std::cout << "Preparing input " << in.id << "\n";
            RESOLVE_INTERFACE_FUNCTION
              (pfd_prepare_input)
              ( in.id
              , options
              , first_step);

            RESOLVE_INTERFACE_FUNCTION
              (write_current_time)
              (in.id, "total_time", options.tmpdir);

            std::cout << "Preparing input " << in.id << " done!\n";

            out = in.id;

          ]]></code>
        </module>
      </defun>
      <connect-in port="in" place="triviality_status"/>
      <connect-read port="options" place="readoptions"/>
      <connect-read port="first_step" place="null_step_name"/>
      <connect-out port="out" place="prepared_input"/>
    </transition>


    <transition name="compute_nullstellensatz">
      <include-function href="pfd_serial_compute_step.xpnet"/>

      <connect-in port="in" place="prepared_input"/>
      <connect-read port="options" place="readoptions"/>
      <connect-read port="step" place="null_step_name"/>
      <connect-out port="out" place="nullstellensatz_done"/>
    </transition>

    <transition name="compute_short_numerator">
      <include-function href="pfd_split_compute_step.xpnet"/>

      <connect-in port="in" place="nullstellensatz_done"/>
      <connect-read port="options" place="readoptions"/>
      <connect-read port="step" place="short_num_name"/>
      <connect-out port="out" place="short_numerator_done"/>
    </transition>

    <transition name="compute_algebraic_dependence">
      <include-function href="pfd_split_compute_step.xpnet"/>

      <connect-in port="in" place="short_numerator_done"/>
      <connect-read port="options" place="readoptions"/>
      <connect-read port="step" place="algebraic_step_name"/>
      <connect-out port="out" place="algebraic_dependence_done"/>
    </transition>


    <transition name="compute_numerator">
      <include-function href="pfd_split_compute_step.xpnet"/>

      <connect-in port="in" place="algebraic_dependence_done"/>
      <connect-read port="options" place="readoptions"/>
      <connect-read port="step" place="numerator_step_name"/>
      <connect-out port="out" place="numerator_done"/>
    </transition>

    <transition name="write_result">
      <defun>
        <require key="worker" mandatory="true"/>
        <in name="in" type="unsigned int"/>
        <in name="options" type="options_type"/>
        <out name="out" type="unsigned int"/>

        <module name="singular_parallel_allpfd"
                require_function_unloads_without_rest="false"
                function="write_result
                            ( options
                            , in
                            , out
                            )">
          <cinclude href="interface/singular_pnet-interface.hpp"/>
          <cinclude href="util-generic/dynamic_linking.hpp"/>
          <cinclude href="iostream"/>
          <code><![CDATA[
          //<>
            std::cout << "Writing " << in << "\n";

            RESOLVE_INTERFACE_FUNCTION
              (log_duration)
              (in, options, "total_time");

            RESOLVE_INTERFACE_FUNCTION
              (pfd_write_result)
              ( in, options );
            std::cout << "Writing " << in << " done!\n";

            out = in;

          ]]></code>
        </module>
      </defun>
      <connect-in port="in" place="numerator_done"/>
      <connect-read port="options" place="readoptions"/>
      <connect-out port="out" place="out"/>
    </transition>

  </net>
</defun>

