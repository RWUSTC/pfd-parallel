<defun name="pfd_compute">

  <include-structs href="types.xpnet"/>

  <require key="worker" mandatory="true"/>

  <in name="in" type="unsigned int" place="intask"/>
  <in name="options" type="options_type"place="readoptions"/>
  <out name="out" type="unsigned int" place="out"/>

  <net>
    <place name="intask" type="unsigned int"/>
    <place name="gen_prep_status" type="task_status"/>
    <place name="prepared_input" type="unsigned int"/>
    <place name="nullstellensatz_done" type="unsigned int"/>
    <place name="short_numerator_done" type="unsigned int"/>
    <place name="algebraic_dependence_done" type="unsigned int"/>
    <place name="numerator_done" type="unsigned int"/>
    <place name="out" type="unsigned int"/>
    <place name="readoptions" type="options_type"/>

    <place name="null_step_name" type="string">
      <token><value>"NSSdecompStep"</value></token>
    </place>
    <place name="short_num_name" type="string">
      <token><value>"shortNumeratorDecompStep"</value></token>
    </place>
    <place name="algebraic_step_name" type="string">
      <token><value>"algDependDecompStep"</value></token>
    </place>
    <place name="numerator_step_name" type="string">
      <token><value>"numeratorDecompStep"</value></token>
    </place>

    <transition name="general_prepare">
      <defun>
        <require key="worker" mandatory="true"/>
        <in name="in" type="unsigned int"/>
        <in name="options" type="options_type"/>
        <in name="first_step" type="string"/>
        <out name="out" type="task_status"/>

        <module name="singular_parallel_allpfd"
                require_function_unloads_without_rest="false"
                function="general_prepare
                            ( options
                            , in
                            , first_step
                            , out
                            )">
          <cinclude href="interface/singular_pnet-interface.hpp"/>
          <cinclude href="util-generic/dynamic_linking.hpp"/>
          <cinclude href="iostream"/>
          <code><![CDATA[
            //<>
            std::cout << "Preparing " << in << "\n";

            unsigned int prep_stat = RESOLVE_INTERFACE_FUNCTION
              (pfd_general_prepare)
              ( in, options, first_step);
            if (prep_stat == 1) {
              std::cout << in << " already done!\n";
            } else if (prep_stat == 2) {
              std::cout << in << " Trivially done!\n";
            } else if (prep_stat == 0) {
              std::cout << in << " still to be computed.\n";
            } else {
              std::cout << in << " has an incorrect return value.\n";
            }
            out.id = in;
            out.status = prep_stat;

          ]]></code>
        </module>
      </defun>
      <connect-in port="in" place="intask"/>
      <connect-read port="options" place="readoptions"/>
      <connect-read port="first_step" place="null_step_name"/>
      <connect-out port="out" place="gen_prep_status"/>
    </transition>

    <transition name="consume_non_compute">
      <defun>
        <require key="worker" mandatory="true"/>
        <in name="in" type="task_status"/>
        <out name="out" type="unsigned int"/>

        <condition>
          ${in.status} :gt: 0U
        </condition>

        <expression>
            ${out} := ${in.id};
        </expression>
      </defun>
      <connect-in port="in" place="gen_prep_status"/>
      <connect-out port="out" place="out"/>
    </transition>

    <transition name="pass_on_to_compute">
      <defun>
        <require key="worker" mandatory="true"/>
        <in name="in" type="task_status"/>
        <out name="out" type="unsigned int"/>

        <condition>
          ${in.status} :eq: 0U
        </condition>

        <expression>
            ${out} := ${in.id};
        </expression>
      </defun>
      <connect-in port="in" place="gen_prep_status"/>
      <connect-out port="out" place="prepared_input"/>
    </transition>


    <transition name="compute_nullstellensatz" inline="true">
      <include-function href="pfd_serial_compute_step.xpnet"/>

      <connect-in port="in" place="prepared_input"/>
      <connect-read port="options" place="readoptions"/>
      <connect-read port="step" place="null_step_name"/>
      <connect-out port="out" place="nullstellensatz_done"/>
    </transition>

    <transition name="compute_short_numerator" inline="true">
      <include-function href="pfd_fork_compute_step.xpnet"/>

      <place-map virtual="in" real="nullstellensatz_done"/>
      <place-map virtual="options" real="readoptions"/>
      <place-map virtual="step" real="short_num_name"/>
      <place-map virtual="decomposition" real="short_numerator_done"/>
    </transition>

    <transition name="compute_algebraic_dependence" inline="true">
      <include-function href="pfd_fork_compute_step.xpnet"/>

      <place-map virtual="in" real="short_numerator_done"/>
      <place-map virtual="options" real="readoptions"/>
      <place-map virtual="step" real="algebraic_step_name"/>
      <place-map virtual="decomposition" real="algebraic_dependence_done"/>
    </transition>

    <transition name="compute_numerator" inline="true">
      <include-function href="pfd_fork_compute_step.xpnet"/>

      <!--
      <connect-in port="in" place="algebraic_dependence_done"/>
      -->
      <place-map virtual="in" real="algebraic_dependence_done"/>
      <place-map virtual="options" real="readoptions"/>
      <place-map virtual="step" real="numerator_step_name"/>
      <place-map virtual="decomposition" real="numerator_done"/>
    </transition>

    <transition name="write_result">
      <defun>
        <require key="worker" mandatory="true"/>
        <in name="in" type="unsigned int"/>
        <in name="options" type="options_type"/>
        <out name="out" type="unsigned int"/>

        <module name="singular_parallel_allpfd"
                require_function_unloads_without_rest="false"
                function="write_result
                            ( options
                            , in
                            , out
                            )">
          <cinclude href="interface/singular_pnet-interface.hpp"/>
          <cinclude href="util-generic/dynamic_linking.hpp"/>
          <cinclude href="iostream"/>
          <code><![CDATA[
          //<>
            std::cout << "Writing " << in << "\n";

            RESOLVE_INTERFACE_FUNCTION
              (pfd_write_result)
              ( in, options );
            std::cout << "Writing " << in << " done!\n";

            out = in;

          ]]></code>
        </module>
      </defun>
      <connect-in port="in" place="numerator_done"/>
      <connect-read port="options" place="readoptions"/>
      <connect-out port="out" place="out"/>
    </transition>

  </net>
</defun>

