<defun name="pfd_fork_compute">

  <include-structs href="types.xpnet"/>

  <require key="worker" mandatory="true"/>
  <in name="in" type="unsigned int" place="in"/>
  <in name="step" type="string" place="step"/>
  <tunnel name="options" type="options_type" place="options"/>
  <out name="out" type="unsigned int" place="decomposition"/>

  <net>
    <place name="in" type="unsigned int"/>
    <place name="step" type="string"/>

    <place name="init_active" type="unsigned int">
      <token><value> 0U </value></token>
    </place>
    <place name="finish_active" type="unsigned int"/>
    <place name="terms" type="term"/>
    <place name="decomposed_terms" type="term"/>

    <place name="left" type="term"/>
    <place name="right" type="term"/>
    <place name="l_active" type="unsigned int">
      <token><value> 0U </value></token>
    </place>
    <place name="r_active" type="unsigned int"/>

    <place name="decomposition" type="unsigned int"/>

    <place name="term_counts" type="term_count_type"/>
    <place name="options" type="options_type" virtual="true"/>

    <transition name="split_init">
      <defun>
        <require key="worker" mandatory="true"/>
        <in name="in" type="unsigned int"/>
        <in name="init_active" type="unsigned int"/>
        <in name="options" type="options_type"/>
        <in name="step" type="string"/>
        <out name="out" type="list"/>
        <out name="finish_active" type="unsigned int"/>
        <out name="counts" type="term_count_type"/>
        <module name="singular_parallel_allpfd"
                require_function_unloads_without_rest="false"
                function="out split_init
                            ( options
                            , in
                            , counts
                            , step
                            , init_active
                            , finish_active
                            )">
          <cinclude href="interface/singular_pnet-interface.hpp"/>
          <cinclude href="util-generic/dynamic_linking.hpp"/>
          <cinclude href="iostream"/>
          <code><![CDATA[
            /*<>*/
            std::cout << "Initializing split "
                      << step << " "
                      << in
                      << "\n";

            RESOLVE_INTERFACE_FUNCTION
              (write_current_time)
              (in, step, options.tmpdir);

            singular_parallel::pnet_list indices = RESOLVE_INTERFACE_FUNCTION
               (pfd_fork_init)
               ( in
               , options
               , step
               );
            std::cout << step
                      << " "
                      << in
                      << " split into "
                      << indices.size()
                      << " terms.\n";

            counts.computing = indices.size();
            counts.id = in;
            finish_active=init_active;

            std::cout << "Initializing split "
                      << step << " "
                      << in
                      << " done!\n";
            return indices;
          ]]></code>
        </module>
      </defun>
      <connect-in port="in" place="in"/>
      <connect-in port="init_active" place="init_active"/>
      <connect-read port="options" place="options"/>
      <connect-read port="step" place="step"/>
      <connect-out-many port="out" place="terms"/>
      <connect-out port="finish_active" place="finish_active"/>
      <connect-out port="counts" place="term_counts"/>
    </transition>

    <transition name="fork_compute">
      <defun>
        <require key="worker" mandatory="true"/>
        <in name="term" type="term"/>
        <in name="options" type="options_type"/>
        <in name="step" type="string"/>
        <out name="out" type="term"/>
        <module name="singular_parallel_allpfd"
                require_function_unloads_without_rest="false"
                function="fork_compute
                            ( options
                            , term
                            , out
                            , step
                            )">
          <cinclude href="interface/singular_pnet-interface.hpp"/>
          <cinclude href="util-generic/dynamic_linking.hpp"/>
          <cinclude href="iostream"/>
          <code><![CDATA[
            /*<>*/

            RESOLVE_INTERFACE_FUNCTION
              (pfd_fork_compute_term)
              ( term.id, term.term_id, options , step);

            out = term;

          ]]></code>
        </module>
      </defun>
      <connect-in port="term" place="terms"/>
      <connect-read port="options" place="options"/>
      <connect-read port="step" place="step"/>
      <connect-out port="out" place="decomposed_terms"/>
    </transition>

    <transition name="populate_left">
      <defun>
        <require key="worker" mandatory="true"/>
        <in name="term" type="term"/>
        <in name="l_active" type="unsigned int"/>
        <out name="left" type="term"/>
        <out name="r_active" type="unsigned int"/>
        <expression>
            ${left} := ${term};
            ${r_active} := ${l_active};
        </expression>
      </defun>
      <connect-in port="term" place="decomposed_terms"/>
      <connect-in port="l_active" place="l_active"/>
      <connect-out port="r_active" place="r_active"/>
      <connect-out port="left" place="left"/>
    </transition>

    <transition name="populate_right">
      <defun>
        <require key="worker" mandatory="true"/>
        <in name="term" type="term"/>
        <in name="r_active" type="unsigned int"/>
        <out name="right" type="term"/>
        <out name="l_active" type="unsigned int"/>
        <expression>
            ${right} := ${term};
            ${l_active} := ${r_active};
        </expression>
      </defun>
      <connect-in port="term" place="decomposed_terms"/>
      <connect-in port="r_active" place="r_active"/>
      <connect-out port="l_active" place="l_active"/>
      <connect-out port="right" place="right"/>
    </transition>


    <transition name="merge_decomposed">
      <defun>
        <require key="worker" mandatory="true"/>
        <in name="left" type="term"/>
        <in name="right" type="term"/>
        <in name="options" type="options_type"/>
        <in name="step" type="string"/>
        <inout name="counts" type="term_count_type"/>
        <out name="decomped" type="term"/>

        <condition>
          ${counts.computing} :gt: 1U :and:
          ${left.id} :eq: ${right.id} :and:
          ${counts.id} :eq: ${left.id}
        </condition>

        <module name="singular_parallel_allpfd"
                require_function_unloads_without_rest="false"
                function="merge_decomposed
                            ( options
                            , left
                            , right
                            , counts
                            , step
                            , decomped
                            )">
          <cinclude href="interface/singular_pnet-interface.hpp"/>
          <cinclude href="util-generic/dynamic_linking.hpp"/>
          <cinclude href="iostream"/>
          <code><![CDATA[
            /*<>*/


            std::cout << "Merging terms "
                      << left.term_id
                      << " and "
                      << right.term_id
                      <<" for " + step + " "
                      << "\n";
            decomped.id = left.id;
            decomped.term_id = RESOLVE_INTERFACE_FUNCTION
               (pfd_fork_merge_pair)
               ( left.id, left.term_id, right.term_id, options, step);

            std::cout << "Merging terms "
                      << left.term_id
                      << " and "
                      << right.term_id
                      <<" for " + step + " "
                      << left.id
                      << " done\n";

            counts.computing -= 1;

          ]]></code>
        </module>
      </defun>
      <connect-in port="left" place="left"/>
      <connect-in port="right" place="right"/>
      <connect-read port="options" place="options"/>
      <connect-read port="step" place="step"/>
      <connect-inout port="counts" place="term_counts"/>
      <connect-out port="decomped" place="decomposed_terms"/>
    </transition>

    <transition name="finish_step">
      <defun>
        <require key="worker" mandatory="true"/>
        <in name="options" type="options_type"/>
        <in name="step" type="string"/>
        <in name="term" type="term"/>
        <in name="finish_active" type="unsigned int"/>
        <in name="counts" type="term_count_type"/>
        <out name="out" type="unsigned int"/>
        <out name="init_active" type="unsigned int"/>
        <condition>
          ${counts.computing} :eq: 1U :and:
          ${counts.id} :eq: ${term.id}
        </condition>
        <module name="singular_parallel_allpfd"
                require_function_unloads_without_rest="false"
                function="finish_step
                             ( options
                             , term
                             , counts
                             , out
                             , step
                             , init_active
                             , finish_active
                             )">
          <cinclude href="interface/singular_pnet-interface.hpp"/>
          <cinclude href="util-generic/dynamic_linking.hpp"/>
          <cinclude href="iostream"/>
          <code><![CDATA[
            /*<>*/

            RESOLVE_INTERFACE_FUNCTION
               (pfd_fork_finish)
               ( term.id, term.term_id, options, step);

            RESOLVE_INTERFACE_FUNCTION
              (log_duration)
              (term.id, options, step);

            init_active=finish_active;
            out = term.id;

          ]]></code>
        </module>
      </defun>
      <connect-read port="options" place="options"/>
      <connect-in port="finish_active" place="finish_active"/>
      <connect-in port="term" place="left"/>
      <connect-in port="counts" place="term_counts"/>
      <connect-read port="step" place="step"/>
      <connect-out port="init_active" place="init_active"/>
      <connect-out port="out" place="decomposition"/>
    </transition>
  </net>
</defun>

