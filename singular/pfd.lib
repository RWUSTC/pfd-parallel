////////////////////////////////////////////////////////////////////
version="version pfd.lib 4.1.3.2 Aug_2020 ";
category="??";
info="
LIBRARY: pfd.lib Multivariate Partial Fraction Decomposition

AUTHOR: Marcel Wittmann, e-mail: mwittman@mathematik.uni-kl.de

OVERVIEW:
This Library implements an algorithm based on the work of E. K. Leinartas to
write rational functions in mutiple variables as a sum of functions with
\"smaller\" numerators and denominators.
This can be used to shorten the IBP reduction coeffcients of multi-loop Feynman
integrals. For this application,
we also provide a procedure that applies the algorithm to all entries of a
matrix of rational functions given as one (possibly very big) txt-file.
If you use the library pfd.lib, please cite the corresponding paper
[J. Boehm, M. Wittmann, Z. Wu, Y. Xu, Y. Zhang: 'IBP reduction coefficients
made simple'] (preprint 2020).

KEYWORDS: partial fraction; decomposition; Leinartas

PROCEDURES:
  pfd();                  calculate a partial fraction decomposition
                          of a rational function
  checkpfd();             test if a decomposition is equal to a rational
                          function given by numerator/denominator polynomials
  evaluatepfd();          substitute values in a partial fraction
                          decomposition gotten from @code{pfd}
  displaypfd();           print a decomposition gotten as output of @code{pfd}
  displaypfd_long();      like @code{display}, but denominators are written out
  getStringpfd();         turn a decomposition gotten from @code{pfd} into one
                          string
  getStringpfd_indexed(); like @code{getStringpfd}, but writes the denominator
                          factors just as @code{q1}, @code{q2}, ...
  readInputTXT();         read a matrix of rational functions from a txt-file
  pfdMat();               apply @code{pfd} to a matrix of rational functions
                          in parallel (using @ref{parallel_lib}) and save result
                          as easy-to-read txt-files.
  checkpfdMat();          test output files of @code{pfdMat} for correctness
";
/////////////////////////////////////////////////////////////////////////////

static proc mod_init()
{
LIB "random.lib";
LIB "ring.lib";
LIB "parallel.lib";
LIB "elim.lib";
LIB "polylib.lib";
//LIB "poly.lib";
LIB "general.lib";
LIB "matrix.lib";
//LIB "dmodapp.lib"

/////////////////////////////////////////////////////////////////////////////

  printlevel = 2;
  system("reference");
  system("--ticks-per-sec",1000);

  // new type for rational functions saved as partial fraction decompositions:
  newstruct("partfrac","ideal q, list terms");
  system("install","partfrac","print",displaypfd,1);
  system("install","partfrac","string",getStringpfd,4);
  system("install","partfrac","+",addpfd,2);
  system("install","partfrac","-",negpfd,1);
  system("install","partfrac","-",subpfd,2);
  system("install","partfrac","*",multpfd,2);
  system("install","partfrac","^",powpfd,2);
  system("install","partfrac","/",divpfd,2);
  system("install","partfrac","==",equalpfd,2);
  system("install","partfrac","<>",notequalpfd,2);
  system("install","partfrac","=",makepfd,1);
  system("install","partfrac","[",getTermpfd,2);
  system("install","partfrac","numerator",numpfd,1);
  system("install","partfrac","denominator",denompfd,1);
  system("install","partfrac","size",sizepfd,1);
  system("install","partfrac","deg",degpfd,1); //numerator degree

  int autoprune = 1;       // if set to 1: factors, that no longer appear in any
  exportto(Pfd,autoprune); // denominator are removed from the ideals <...>.q

  // version with globally saved ideal of denomnator factors:
  newstruct("partfrac2","list terms");
  system("install","partfrac2","print",displaypfd,1);
  system("install","partfrac2","string",getStringpfd,4);
  system("install","partfrac2","+",addpfd2,2);
  system("install","partfrac2","-",negpfd2,1);
  system("install","partfrac2","-",subpfd2,2);
  system("install","partfrac2","*",multpfd2,2);
  system("install","partfrac2","^",powpfd2,2);
  system("install","partfrac2","/",divpfd2,2);
  system("install","partfrac2","==",equalpfd2,2);
  system("install","partfrac","<>",notequalpfd2,2);
  system("install","partfrac2","=",makepfd2,1);
  system("install","partfrac2","[",getTermpfd2,2);
  system("install","partfrac2","numerator",numpfd2,1);
  system("install","partfrac2","denominator",denompfd2,1);
  system("install","partfrac2","size",sizepfd2,1);
  system("install","partfrac2","deg",degpfd2,1); //numerator degree

  int autoexpand = 1;       // if set to 1: new denominator factors will auto-
  exportto(Pfd,autoexpand); // automaticly be appended to denominator_factors

  int ignore_nonlinear_factors = 1;
  exportto(Pfd,ignore_nonlinear_factors);

  int debug_mode = 0;
  exportto(Pfd,debug_mode);

  int batch_size = 10;
  exportto(Pfd,batch_size);

  int parallelize_partfrac_multiplication = 0;
  exportto(Pfd,parallelize_partfrac_multiplication);

  int parallelize_matrix_multiplication = 1;
  exportto(Pfd,parallelize_matrix_multiplication);

  int doLinearDependencyRemoval = 0;
  exportto(Pfd,doLinearDependencyRemoval);

  // export some static functions so they can be run in parallel using parallelWaitAll:
  if (!defined(Tasks)) {LIB "tasks.lib";}
  exportto(Tasks,pfdWrap);
  importfrom(Tasks,pfdWrap);
  exportto(Pfd,pfdWrap);
  exportto(Tasks,testEntry);
  importfrom(Tasks,testEntry);
  exportto(Pfd,testEntry);
  exportto(Tasks,main_part_of_pfd_parallel);
  importfrom(Tasks,main_part_of_pfd_parallel);
  exportto(Pfd,main_part_of_pfd_parallel);
  exportto(Tasks,matrix_multiplication_parallel);
  importfrom(Tasks,matrix_multiplication_parallel);
  exportto(Pfd,matrix_multiplication_parallel);
}


// partfrac Constructors and Functionality /////////////////////////////////////

proc makepfd(list #)
"USAGE:   makepfd(f,g[,debug]);   f,g poly, debug int
          makepfd(f,g[,debug]);   f poly, g list, debug int
          makepfd(arguments[, parallelize]);     arguments list, parallelize int
RETURN:   a partial fraction decomposition of f/g as a variable of type
          @code{partfrac}. The input structure is the same as for @ref{pfd}.
NOTE:     The result depends on the monomial ordering and the current basering.
SEE ALSO: checkpfd, evaluatepfd, displaypfd, displaypfd_long, pfdMat
EXAMPLE:  example makepfd; shows an example"
{
  partfrac pf;
  if(size(#)==1)
  {
    string t=typeof(#[1]);
    if(t=="partfrac2")
    {
      pf.q = denominator_factors;
      pf.terms = #[1].terms;
      if(autoprune) {return(prunepfd(pf));}
      return(pf);
    }
    if(t!="poly" && t!="int" && t!="bigint" && t!="number")
      {ERROR("wrong argument type");}
    pf.q=ideal();
    if(#[1]==0) {pf.terms = list();}
    else {pf.terms = list(list(poly(#[1]),intvec(0:0),intvec(0:0)));}
    return(pf);
  }
  if(size(#)==2)
  {
    if(typeof(#[1])=="ideal" && typeof(#[2])=="list") // # has the form of an output of pfd()
    {
      pf.q = #[1];
      pf.terms = sort_indices(#[2]);

      // make entries of q unique if nessecary:
      int i,j;
      poly p;
      number c1,c2;
      list constants;
      int b=0;
      for(i=1;i<=size(pf.q);i++)
      {
        p = pf.q[i];
        c1 = leadcoef(p); p=p/c1;
        c2 = content(p); p=p/c2;
        constants[i] = c1*c2;
        if(constants[i]!=1) //pf.q[i] has to be changed
          {pf.q[i] = p; b=1;}
        j = find_entry(pf.q,p);
        if(j<i)
          {ERROR("The " + string(j) + "-th and " + string(i)
                            + "-th denominator factor are linearly dependent");}
      }
      if(b) // pf.q was changed
      {
        for(i=1;i<=size(pf.terms);i++)
        {
          c1 = number(1);
          for(j=1;j<=size(pf.terms[i][2]);j++)
          {
            c1 = c1*constants[pf.terms[i][2][j]]^pf.terms[i][3][j];
          }
          pf.terms[i][1] = pf.terms[i][1]/c1; // pull constants into numerator!
        }
      }

      // pf = sortq(pf);
      if(size(pf.terms)==1) {if(pf.terms[1][1]==0) {pf.terms = list();}}
      if(autoprune) {return(prunepfd(pf));}
      return(pf);
    }
  }
  // else just call pfd() on the input arguments
  list dec = pfd(#);
  pf.q = dec[1];
  pf.terms = dec[2];
  // pf = sortq(pf);
  if(autoprune) {return(prunepfd(pf));}
  return(pf);
}
example
{
  "EXAMPLE:";
  echo=voice;
  ring R = 0,(s12,s15,s23,s34,s45),dp;
  poly f = 7*s12^4*s15^2 + 11*s12^3*s15^3 + 4*s12^2*s15^4 - 10*s12^4*s15*s23
    - 14*s12^3*s15^2*s23 - 4*s12^2*s15^3*s23 + 3*s12^4*s23^2 + 3*s12^3*s15*s23^2
    + 13*s12^4*s15*s34 + 12*s12^3*s15^2*s34 + 2*s12^2*s15^3*s34
    - 5*s12^4*s23*s34 + 33*s12^3*s15*s23*s34 + 49*s12^2*s15^2*s23*s34
    + 17*s12*s15^3*s23*s34 - 17*s12^3*s23^2*s34 - 19*s12^2*s15*s23^2*s34
    - 5*s12*s15^2*s23^2*s34 - 24*s12^3*s15*s34^2 - 15*s12^2*s15^2*s34^2
    + 2*s12*s15^3*s34^2 + 15*s12^3*s23*s34^2 - 34*s12^2*s15*s23*s34^2
    - 31*s12*s15^2*s23*s34^2 + 2*s15^3*s23*s34^2 + 33*s12^2*s23^2*s34^2
    + 29*s12*s15*s23^2*s34^2 + 5*s15^2*s23^2*s34^2 + 9*s12^2*s15*s34^3
    - 4*s12*s15^2*s34^3 - 15*s12^2*s23*s34^3 + 9*s12*s15*s23*s34^3
    - 4*s15^2*s23*s34^3 - 27*s12*s23^2*s34^3 - 13*s15*s23^2*s34^3
    + 2*s12*s15*s34^4 + 5*s12*s23*s34^4 + 2*s15*s23*s34^4 + 8*s23^2*s34^4
    - 6*s12^3*s15^2*s45 - 9*s12^2*s15^3*s45 - 2*s12*s15^4*s45
    + 30*s12^3*s15*s23*s45 + 56*s12^2*s15^2*s23*s45 + 24*s12*s15^3*s23*s45
    - 12*s12^3*s23^2*s45 - 23*s12^2*s15*s23^2*s45 - 10*s12*s15^2*s23^2*s45
    - 30*s12^3*s15*s34*s45 - 32*s12^2*s15^2*s34*s45 - 6*s12*s15^3*s34*s45
    + 7*s12^3*s23*s34*s45 - 86*s12^2*s15*s23*s34*s45 - 104*s12*s15^2*s23*s34*s45
    - 15*s15^3*s23*s34*s45 + 41*s12^2*s23^2*s34*s45 + 51*s12*s15*s23^2*s34*s45
    + 10*s15^2*s23^2*s34*s45 - 5*s12^3*s34^2*s45 + 33*s12^2*s15*s34^2*s45
    + 14*s12*s15^2*s34^2*s45 - 2*s15^3*s34^2*s45 - 21*s12^2*s23*s34^2*s45
    + 62*s12*s15*s23*s34^2*s45 + 28*s15^2*s23*s34^2*s45 - 46*s12*s23^2*s34^2*s45
    - 28*s15*s23^2*s34^2*s45 + 10*s12^2*s34^3*s45 - s12*s15*s34^3*s45
    + 4*s15^2*s34^3*s45 + 21*s12*s23*s34^3*s45 - 6*s15*s23*s34^3*s45
    + 17*s23^2*s34^3*s45 - 5*s12*s34^4*s45 - 2*s15*s34^4*s45 - 7*s23*s34^4*s45
    - 6*s12^2*s15^2*s45^2 - 5*s12*s15^3*s45^2 - 2*s15^4*s45^2
    - 28*s12^2*s15*s23*s45^2 - 42*s12*s15^2*s23*s45^2 - 10*s15^3*s23*s45^2
    + 9*s12^2*s23^2*s45^2 + 10*s12*s15*s23^2*s45^2 + 24*s12^2*s15*s34*s45^2
    + 36*s12*s15^2*s34*s45^2 + 10*s15^3*s34*s45^2 - 11*s12^2*s23*s34*s45^2
    + 31*s12*s15*s23*s34*s45^2 + 25*s15^2*s23*s34*s45^2
    - 18*s12*s23^2*s34*s45^2 - 10*s15*s23^2*s34*s45^2 + 4*s12^2*s34^2*s45^2
    - 29*s12*s15*s34^2*s45^2 - 17*s15^2*s34^2*s45^2 + 27*s12*s23*s34^2*s45^2
    + 2*s15*s23*s34^2*s45^2 + 9*s23^2*s34^2*s45^2 - 3*s12*s34^3*s45^2
    + 10*s15*s34^3*s45^2 - 16*s23*s34^3*s45^2 - s34^4*s45^2 + 6*s12*s15^2*s45^3
    + 3*s15^3*s45^3 + 8*s12*s15*s23*s45^3 + 10*s15^2*s23*s45^3
    - 8*s12*s15*s34*s45^3 - 10*s15^2*s34*s45^3 + 9*s12*s23*s34*s45^3
    + s12*s34^2*s45^3 + 8*s15*s34^2*s45^3 - 9*s23*s34^2*s45^3 - s34^3*s45^3
    - s15^2*s45^4 + s15*s34*s45^4;
  poly g = 4*s12*s15*(s12 + s15 - s34)*(s15 - s23 - s34)*(s12 + s23 - s45)
                                 *(s12 - s34 - s45)*(s12 + s15 - s34 - s45)*s45;

  partfrac pf = f,g; // pf represents f/g

  print(pf);
  displaypfd(pf);
  checkpfd(list(f,g),pf);

  print(pf+pf);

  print(pf^2);
}

static proc equalpfd(partfrac pf1, partfrac pf2)
{
  pf2 = negpfd(pf2);
  ideal q;
  list terms1,terms2;
  terms1 = pf1.terms;
  q,terms2 = mergeq(pf1.q,pf2.q,pf2.terms);
  terms2 = sort_indices(terms2);
  partfrac pf;
  pf.q = q;
  pf.terms = mergepfd(terms1,terms2);
  return(checkpfd(list(poly(0),poly(1)), pf)); // test if difference is zero
}

static proc notequalpfd(partfrac pf1, partfrac pf2)
{
  return(not(equalpfd(pf1,pf2)));
}

static proc addpfd(partfrac pf1, partfrac pf2)
{
  ideal q;
  list terms1,terms2;
  terms1 = pf1.terms;
  q,terms2 = mergeq(pf1.q,pf2.q,pf2.terms);
  terms2 = sort_indices(terms2);
  partfrac pf;
  pf.q = q;
  pf.terms = mergepfd(terms1,terms2);
  if(doLinearDependencyRemoval)
  {
    if(debug_mode)
    {
      link ll=":a "+string(debug_mode)+"_log_"+datetime()+".txt";
      pf.terms = removeLinDepend(pf.terms, pf.q, debug_mode, ll);
    }
    else
    {
      pf.terms = removeLinDepend(pf.terms, pf.q);
    }
  }
  if(autoprune) {return(prunepfd(pf));}
  return(pf);
}

static proc negpfd(partfrac pf)
{
  partfrac minuspf;
  minuspf.q = pf.q;
  list terms = pf.terms;
  int n = size(terms);
  for(int i=1; i<=n; i++)
  {
    terms[i][1] = -terms[i][1];
  }
  minuspf.terms = terms;
  return(minuspf);
}

static proc subpfd(partfrac pf1, partfrac pf2)
{
  return(addpfd(pf1,negpfd(pf2)));
}

static proc multpfd(partfrac pf1, partfrac pf2)
{
  list times; int tt=rtimer;
  /*
  if(typeof(pf1)=="partfrac" && (typeof(pf2)=="int" || typeof(pf2)=="bigint" || typeof(pf2)=="poly" || typeof(pf2)=="number"))
  {
    for(int i=1; i<=size(pf1.terms); i++)
      {pf1.terms[i][1] = pf1.terms[i][1]*pf2;}
    return(pf1);
  }
  if(typeof(pf2)=="partfrac" && (typeof(pf1)=="int" || typeof(pf1)=="bigint" || typeof(pf1)=="poly" || typeof(pf1)=="number"))
  {
    for(int i=1; i<=size(pf2.terms); i++)
      {pf2.terms[i][1] = pf2.terms[i][1]*pf1;}
    return(pf2);
  }
  if(typeof(pf1)!="partfrac" || typeof(pf2)!="partfrac")
    {ERROR("wrong type for multpfd");} */
  ideal q;
  list terms1,terms2;
  terms1 = pf1.terms;
  q,terms2 = mergeq(pf1.q,pf2.q,pf2.terms);
  if(size(terms1)==0 || size(terms2)==0) {partfrac pf; pf.q=q; pf.terms = list(); return(pf);}
  times[size(times)+1] = rtimer-tt; dbprint(sprintf("merging q vectors: %sms",rtimer-tt)); tt=rtimer;
  int sizeq = size(q);
  int n1,n2 = size(terms1),size(terms2);
  int i,j,k,l;
  list terms;
  list t1,t2,newterm;
  intvec indices;
  for(i=1; i<=n1; i++)
  {
    for(j=1; j<=n2; j++)
    {
      t1 = terms1[i];
      t2 = terms2[j];
      newterm[1] = t1[1] * t2[1];
      newterm[2] = intvec(0:0);
      newterm[3] = intvec(0:0);
      indices = 0:sizeq;
      for(k=1; k<=size(t1[2]); k++)
      {
        indices[t1[2][k]]=t1[3][k];
      }
      for(k=1; k<=size(t2[2]); k++)
      {
        indices[t2[2][k]]=indices[t2[2][k]]+t2[3][k];
      }
      l = 0;
      for(k=1; k<=sizeq; k++)
      {
        if(indices[k]>0)
        {
          l++;
          newterm[2][l]=k;
          newterm[3][l]=indices[k];
        }
      }
      terms = mergepfd(terms, list(newterm));
    }
  }
  times[size(times)+1] = rtimer-tt; dbprint(sprintf("building product terms: %sms",rtimer-tt)); tt=rtimer;

  // apply pfd to the list of product terms:
  partfrac pf;
  pf.q=q;
  if(ignore_nonlinear_factors)
  {
    indices=0:0;
    for(i=1;i<=size(q);i++)
      {indices[i]=(deg(q[i])>1);}
    list part_terms; // terms partitioned by nonlinear factors
    intvec I,E;
    list nonlin_fact;
    for(i=1;i<=size(terms);i++)
    {
      I = 0:0;
      E = 0:0;
      for(j=1;j<=size(terms[i][2]);j++)
      {
        k = terms[i][2][j];
        if(indices[k]) // q[terms[i][2][j]] is nonlinear
        {
          I[size(I)+1] = k;
          E[size(E)+1] = terms[i][3][j];
          terms[i][2] = delete(terms[i][2],j);
          terms[i][3] = delete(terms[i][3],j);
          continue;
        }
      }

      k = find_entry(nonlin_fact, list(I,E)); // assumes I to be sorted !

      if(k==0)
      {
        k = size(nonlin_fact) + 1;
        nonlin_fact[k] = list(I,E);
        part_terms[k] = list(q,list(terms[i]));
      }
      else
      {
        part_terms[k][2][size(part_terms[k][2])+1] = terms[i];
      }
    }

    times[size(times)+1] = rtimer-tt; dbprint(sprintf("extracting nonlinear factors: %sms",rtimer-tt)); tt=rtimer;
    list results;
    if(parallelize_partfrac_multiplication)
      {results = parallelWaitAll("main_part_of_pfd_parallel",part_terms);}
    else
    {
      if(debug_mode)
      {
        link ll;
        for(i=1;i<=size(part_terms);i++)
        {
          ll=":a "+string(debug_mode*100000+i)+"_log_"+datetime()+".txt";
          results[i] = main_part_of_pfd(q,terms,0,debug_mode,ll)[2];
        }
      }
      else
      {
        for(i=1;i<=size(part_terms);i++)
          {results[i] = main_part_of_pfd(q,terms,0,0,link(""))[2];}
      }
    }
    times[size(times)+1] = rtimer-tt; dbprint(sprintf("pfd: %sms",rtimer-tt)); tt=rtimer;

    pf.terms = list();
    list newterms;
    for(i=1; i<=size(results); i++)
    {
      newterms = results[i];
      I=nonlin_fact[i][1];
      E=nonlin_fact[i][2];
      k = size(I);
      for(j=1;j<=size(newterms);j++)
      {
        l = size(newterms[j][2]);
        indices = newterms[j][2];
        if(k==1) {indices[l+1] = I[1];}
        else {indices[l+1..l+k] = I;}
        newterms[j][2] = indices;
        indices = newterms[j][3];
        if(k==1) {indices[l+1] = E[1];}
        else {indices[l+1..l+k] = E;}
        newterms[j][3] = indices;
      }
      newterms = sort_indices(newterms);
      pf.terms = mergepfd(pf.terms,newterms);
    }
    times[size(times)+1] = rtimer-tt; dbprint(sprintf("adding nonlinear factors back in: %sms",rtimer-tt)); tt=rtimer;
  }
  else
  {
    pf.terms = main_part_of_pfd(q,terms,0,0,link(""))[2];
    times[size(times)+1] = rtimer-tt; dbprint(sprintf("pfd: %sms",rtimer-tt)); tt=rtimer;
  }

  if(autoprune)
  {
    pf = prunepfd(pf);
    times[size(times)+1] = rtimer-tt; dbprint(sprintf("pruning: %sms",rtimer-tt));
  }
  if(size(pf.terms)==0) {pf.terms[1] = list(poly(0),intvec(0:0),intvec(0:0));}
  if(debug_mode) {return(pf,times);}
  return(pf);
}

static proc main_part_of_pfd_parallel(ideal q, list terms)
{
  list dec = main_part_of_pfd(q,terms,0,0,link(""));
  return(dec[2]);
}

static proc powpfd(partfrac pf, int n)
{
  if(n<0)  {pf = invpfd(pf); n=-n;}
  if(n==0) {return(partfrac(poly(1),poly(1)));}
  if(n==1) {return(pf);}
  partfrac tmp = powpfd(pf, n div 2);
  if(n mod 2==0) {return(multpfd(tmp,tmp));}
  else {return(multpfd(multpfd(tmp,tmp),pf));}
}

static proc divpfd(partfrac pf1, partfrac pf2)
{
  return(multpfd(pf1,invpfd(pf2)));
}

static proc invpfd(partfrac pf)
{
  poly num,den = numdenompfd(pf);
  if(num==0) {ERROR("division by zero");}
  return(makepfd(den,num));
}

static proc getTermpfd(partfrac pf, int i)
{
  return(pf.terms[i]);
}

static proc sizepfd(partfrac pf)
{
  return(size(pf.terms));
}

/* old version with sorted q
static proc mergeq(partfrac pf1, partfrac pf2)
{
  ideal q1 = pf1.q;
  ideal q2 = pf2.q;
  int n1,n2=size(q1),size(q2);
  if(n1==0) {return(pf2.q,pf1.terms,pf2.terms);}
  if(n2==0) {return(pf1.q,pf1.terms,pf2.terms);}
  ideal q; // now n1,n2 = size of q1,q2 and both both are >0
  intvec ind1,ind2;

  printf("%nq1 (%s): %s",size(q1),q1);
  printf("q2 (%s): %s",size(q2),q2);

  // sort q <- (q1,q2) via a mergesort step and remember index permutation:
  int i,j,k,l = 1,1,1,0;
  list indices;
  while(1)
  {
    printf("i=%s, j=%s, k=%s, q1[i]=%s, q2[j]=%s, q1[i]<q2[j]: %s, q1[i]>q2[j]: %s",i,j,k,q1[i],q2[j],q1[i]<q2[j],q1[i]>q2[j]);
    if(q1[i]<q2[j])
    {
      q[k] = q1[i]; printf("< added q1[i]=%s",q1[i]);
      indices[k] = intvec(i,0);
      i++;
      k++;
    }
    else{if(q1[i]>q2[j])
    {
      q[k] = q2[j]; printf("> added q2[j]=%s",q2[j]);
      indices[k] = intvec(0,j);
      j++;
      k++;
    }
    else // so q1[i] == q2[j]
    {
      q[k] = q1[i]; printf("= added q1[i]=%s",q1[i]);
      indices[k] = intvec(i,j);
      i++;
      j++;
      k++;
    }}
    if(i>n1)
    {
      printf("q (%s): %s",size(q),q);
      if(j>n2) {break;}
      q = q+ideal(q2[j..n2]);
      for(l=0; l<=n2-j; l++)
        {indices[k+l] = intvec(0,j+l);}
      break;
    }
    if(j>n2)
    {
      printf("q (%s): %s",size(q),q);
      if(i>n1) {break;}
      q = q+ideal(q1[i..n1]);
      for(l=0; l<=n1-i; l++)
        {indices[k+l] = intvec(i+l,0);}
      break;
    }
  }

  //create two intvecs recording the index shifts needed in pf1 and pf2:
  for(i=1; i<=size(q); i++)
  {
    k,l = indices[i];
    if(k!=0) {ind1[k]=i;}
    if(l!=0) {ind2[l]=i;}
  }

  printf("q (%s): %s",size(q),q);
  printf("ind1 (%s): %s",size(ind1),ind1);
  printf("ind2 (%s): %s",size(ind2),ind2);

  // change indices in each denominator:
  for(i=1; i<=size(pf1.terms); i++)
  {
    for(j=1; j<=size(pf1.terms[i][2]); j++)
      {pf1.terms[i][2][j]=ind1[pf1.terms[i][2][j]];}
  }
  for(i=1; i<=size(pf2.terms); i++)
  {
    for(j=1; j<=size(pf2.terms[i][2]); j++)
      {pf2.terms[i][2][j]=ind2[pf2.terms[i][2][j]];}
  }
  return(q,pf1.terms,pf2.terms);
}
*/

static proc mergeq(ideal q, ideal q2, list terms2)
{
  int n1,n2 = size(q),size(q2);
  if(n1==0) {return(q2,terms2);}
  if(n2==0) {return(q,terms2);}
  int i,j;

  //create an intvec 'ind' recording the index shifts needed in pf2:
  intvec ind=0:0;
  for(i=1; i<=n2; i++)
  {
    j = find_entry(q,q2[i]);
    if(j==0) {j=size(q)+1; q[j] = q2[i];}
    ind[i] = j;
  }

  // change indices in each denominator:
  for(i=1; i<=size(terms2); i++)
  {
    for(j=1; j<=size(terms2[i][2]); j++)
      {terms2[i][2][j]=ind[terms2[i][2][j]];}
  }
  return(q,terms2);
}

proc sortq(partfrac pf)
{
  ideal q_in = pf.q;
  int nq=size(q_in);
  if(nq==0) {return(pf);}
  int i,j;

  list l = sort(q_in);
  ideal q = l[1];
  intvec indices = l[2];

  intvec ind;
  for(i=1; i<=nq; i++)
  {
    ind[indices[i]]=i;
  }

  // change indices in each denominator:
  intvec e;
  for(i=1; i<=size(pf.terms); i++)
  {
    for(j=1; j<=size(pf.terms[i][2]); j++)
      {pf.terms[i][2][j]=ind[pf.terms[i][2][j]];}
  }
  pf.terms = sort_indices(pf.terms);
  pf.q = q;
  return(pf);
}

static proc sort_indices(list terms)
{
  // sort indices in each denominator:
  intvec e;
  list l;
  for(int i=1; i<=size(terms); i++)
  {
    if(size(terms[i][2])==0) {i++; continue;}
    l = sort(terms[i][2]);
    terms[i][2] = l[1];
    e = terms[i][3];
    terms[i][3] = intvec(e[l[2]]);
  }
  terms = mergepfd(list(),terms); // sort terms again
  return(terms);
}

static proc numpfd(partfrac pf)
{
  ideal q = pf.q;
  list terms = pf.terms;

  if(size(terms)==0) {return(poly(0));}
  int m = size(q);
  if(m==0) {return(terms[1][1]);} // no denominator factors

  int jmax,j,ind,k;
  intvec e_max=0:m;
  int imax = size(terms);
  for(int i=1; i<=imax; i++)
  {
    jmax = size(terms[i][2]);
    for(j=1; j<=jmax; j++)
    {
      ind = terms[i][2][j];
      e_max[ind] = max(e_max[ind],terms[i][3][j]);
    }
  }
  poly num;
  poly sum_of_numerators = 0;
  intvec e;
  for(i=1; i<=imax; i++)
  {
    e = e_max;
    jmax = size(terms[i][2]);
    for(j=1; j<=jmax; j++)
    {
      ind = terms[i][2][j];
      e[ind] = e[ind]-terms[i][3][j];
    }
    num = terms[i][1];
    for(j=1; j<=m; j++)
      {num = num * q[j]^(e[j]);}
    sum_of_numerators = sum_of_numerators + num;
  }

  return(sum_of_numerators);
}

static proc denompfd(partfrac pf)
{
  ideal q = pf.q;
  list terms = pf.terms;

  int m = size(q);
  if(size(terms)==0 || m==0) {return(poly(1));} // no denominator factors

  int jmax,j,ind;
  intvec e_max=0:m;
  int imax = size(terms);
  for(int i=1; i<=imax; i++)
  {
    jmax = size(terms[i][2]);
    for(j=1; j<=jmax; j++)
    {
      ind = terms[i][2][j];
      e_max[ind] = max(e_max[ind],terms[i][3][j]);
    }
  }

  poly den = 1;
  for(i=1; i<=m; i++)
  {
    den = den * q[i]^e_max[i];
  }
  return(den);
}

static proc numdenompfd(partfrac pf)
{
  ideal q = pf.q;
  list terms = pf.terms;

  if(size(terms)==0) {return(poly(0),poly(1));}
  int m = size(q);
  if(m==0) {return(terms[1][1],poly(1));}

  int jmax,j,ind,k;
  intvec e_max=0:m;
  int imax = size(terms);
  for(int i=1; i<=imax; i++)
  {
    jmax = size(terms[i][2]);
    for(j=1; j<=jmax; j++)
    {
      ind = terms[i][2][j];
      e_max[ind] = max(e_max[ind],terms[i][3][j]);
    }
  }
  poly num;
  poly sum_of_numerators = 0;
  intvec e;
  for(i=1; i<=imax; i++)
  {
    e = e_max;
    jmax = size(terms[i][2]);
    for(j=1; j<=jmax; j++)
    {
      ind = terms[i][2][j];
      e[ind] = e[ind]-terms[i][3][j];
    }
    num = terms[i][1];
    for(j=1; j<=m; j++)
      {num = num * q[j]^(e[j]);}
    sum_of_numerators = sum_of_numerators + num;
  }

  poly den = 1;
  for(i=1; i<=m; i++)
  {
    den = den * q[i]^e_max[i];
  }

  return(sum_of_numerators,den);
}

static proc degpfd(partfrac pf) // max. numerator degree
{
  int d=-1;
  for(int i=1; i<=size(pf.terms); i++)
  {
    d = max(d,deg(pf.terms[i][1]));
  }
  return(d);
}

proc prunepfd(partfrac pf)
{
  int nterms = size(pf.terms);
  int sizeq = size(pf.q);
  int i,j;
  intvec indices = 0:size(pf.q);
  for(i=1; i<=nterms; i++)
  {
    for(j=1; j<=size(pf.terms[i][2]); j++)
    {
      indices[pf.terms[i][2][j]] = 1;
    }
  }

  // delete entries of q and create an intvec recording the index shifts:
  intvec ind;
  j=0;
  for(i=1; i<=sizeq; i++)
  {
    ind[i] = i-j;
    if(indices[i]==0)
      {
        pf.q = delete(pf.q,i-j);
        j++;
      }
  }

  // change indices in each denominator:
  for(i=1; i<=nterms; i++)
  {
    for(j=1; j<=size(pf.terms[i][2]); j++)
      {pf.terms[i][2][j]=ind[pf.terms[i][2][j]];}
  }
  if(size(pf.q)==0) {pf.q=0;}
  return(pf);
}

// partfrac2 Constructors and Functionality /////////////////////////////////////

proc setq(list #)
{
  if(!defined(basering)) {ERROR("no basering defined");}
  int newring=0;
  if(!defined(denominator_factors))
  {
    ideal denominator_factors;
    exportto(Pfd,denominator_factors);
    newring=1;
  }
  ideal q;
  if(size(#)==0)
  {
    denominator_factors = ideal();
    dbprint("changed list of denominator factors to");
    dbprint(denominator_factors);
    if(!newring)
      {dbprint("WARNING: Any previously created partfrac2 objects may be broken!");}
    return();
  }
  if(size(#)==1 && typeof(#[1])=="ideal")
  {
    q = #[1];
    for(int i=1; i<=size(#); i++)
    {
      if(deg(q[i])>0 && size(factorize(q[i])[1])==2)
      {
        q[i] = q[i]/leadcoef(q[i]);
        q[i] = q[i]/content(q[i]);
      }
      else
        {ERROR("only non-constant irreducible polynomials are allowed!")}
    }
  }
  else
  {
    string t;
    for(int i=1; i<=size(#); i++)
    {
      if(typeof(#[i])=="poly")
      {
        if(deg(#[i])>0 && size(factorize(#[i])[1])==2)
        {
          q[i] = #[i];
          q[i] = q[i]/leadcoef(q[i]);
          q[i] = q[i]/content(q[i]);
        }
        else
          {ERROR("only non-constant irreducible polynomials are allowed!")}
      }
      else
        {ERROR("wrong type for "+string(i)+"-th argument, expected poly, got "
                                                                +typeof(#[i]));}
    }
  }

  denominator_factors = q;
  dbprint("changed list of denominator factors to");
  dbprint(denominator_factors);
  if(!newring)
    {dbprint("WARNING: Any previously created partfrac2 objects may be broken!");}
}

proc addq(list #)
{
  if(!defined(denominator_factors))
  {
    ideal denominator_factors;
    exportto(Pfd,denominator_factors);
  }
  ideal q;
  if(size(#)==0)
  {
    dbprint("changed list of denominator factors to");
    dbprint(denominator_factors);
    return();
  }
  if(size(#)==1 && typeof(#[1])=="ideal")
  {
    q = #[1];
    for(int i=1; i<=size(#); i++)
    {
      if(deg(q[i])>0 && size(factorize(q[i])[1])==2)
      {
        q[i] = q[i]/leadcoef(q[i]);
        q[i] = q[i]/content(q[i]);
      }
      else
        {ERROR("only non-constant irreducible polynomials are allowed!")}
    }
  }
  else
  {
    string t;
    for(int i=1; i<=size(#); i++)
    {
      if(typeof(#[i])=="poly")
      {
        if(deg(#[i])>0 && size(factorize(#[i])[1])==2)
        {
          q[i] = #[i];
          q[i] = q[i]/leadcoef(q[i]);
          q[i] = q[i]/content(q[i]);
        }
        else
          {ERROR("only non-constant irreducible polynomials are allowed!")}
      }
      else
        {ERROR("wrong type for "+string(i)+"-th argument, expected poly, got "
                                                                +typeof(#[i]));}
    }
  }

  denominator_factors = denominator_factors + q;
  dbprint("changed list of denominator factors to");
  dbprint(denominator_factors);
}

proc fetchq(def old_ring)
{
  int newring=0;
  if(!defined(denominator_factors))
  {
    ideal denominator_factors;
    exportto(Pfd,denominator_factors);
    newring=1;
  }

  ideal q = fetch(old_ring,denominator_factors);

  for(int i=1; i<=size(denominator_factors); i++)
  {
    if(deg(denominator_factors[i])<=0)
    {
      if(newring) {kill denominator_factors;}
      ERROR("constant denominator factor");
    }
    if(factorize(denominator_factors[i])[1]>2)
    {
      if(newring) {kill denominator_factors;}
      ERROR("denominator factors no longer irreducible");
    }
  }

  denominator_factors = q;

  dbprint("changed list of denominator factors to");
  dbprint(denominator_factors);
  if(!newring)
    {dbprint("WARNING: Any previously created partfrac2 objects may be broken!");}

}

proc getq();
{
  if(!defined(denominator_factors))
    {ERROR("Not defined! Set a list of denominator factors with setq() first.");}
  return(denominator_factors);
}

proc makepfd2(list #)
"USAGE:   makepfd2(f,g[,debug]);   f,g poly, debug int
          makepfd2(f,g[,debug]);   f poly, g list, debug int
          makepfd2(arguments[, parallelize]);     arguments list, parallelize int
          makepfd2(f,ind,exp);   f poly, ind,exp intvec
RETURN:   a partial fraction decomposition of f/g as a variable of type
          @code{partfrac2}. The input structure is the same as for @ref{pfd},
          but additionally the denominator can be given as two intvecs ind,exp
          where ind contains the indices i for which the i-th denominator factor
          (see @ref{getq}) appears in the denominator and exp contains the
          exponents of those factors.
NOTE:     The result depends on the monomial ordering and the current basering.
SEE ALSO: checkpfd, evaluatepfd, displaypfd, displaypfd_long, pfdMat
EXAMPLE:  example makepfd; shows an example"
{
  if(!defined(denominator_factors)) {setq();}
  partfrac2 pf;
  if(size(#)==1)
  {
    string t = typeof(#[1]);
    if(t=="partfrac")
    {
      pf.terms = matchq(#[1].q, #[1].terms, 0);
      return(pf);
    }
    if(t!="poly" && t!="int" && t!="bigint" && t!="number")
      {ERROR("wrong argument type");}
    if(#[1]==0) {pf.terms = list();}
    else {pf.terms = list(list(poly(#[1]),intvec(0:0),intvec(0:0)));} //no denominator
    return(pf);
  }
  if(size(#)==2)
  {
    if(typeof(#[1])=="ideal" && typeof(#[2])=="list")
    {  // assume output of pfd() was given
      pf.terms = matchq(#[1], #[2], 1);
      if(size(pf.terms)==1) {if(pf.terms[1][1]==0) {pf.terms = list();}}
      return(pf);
    }
  }
  string t = typeof(#[1]);
  if(size(#)==3)
  {
    if((t=="poly" || t=="int" || t=="bigint" || t=="number") && typeof(#[2])=="intvec" && typeof(#[3])=="intvec")
    {  //assume the numerator is given as index and exponent intvecs
      list terms = list(list(poly(#[1]),#[2],#[3]));
      pf.terms = main_part_of_pfd(denominator_factors,terms,0,0,link(""))[2];
      return(pf);
    }
  }
  // else just call pfd() on the input arguments
  list dec = pfd(#);
  pf.terms = matchq(dec[1], dec[2], 0);
  return(pf);
}
example
{
  "EXAMPLE:";
  echo=voice;
  ring R = 0,(s12,s15,s23,s34,s45),dp;
  poly f = 7*s12^4*s15^2 + 11*s12^3*s15^3 + 4*s12^2*s15^4 - 10*s12^4*s15*s23
    - 14*s12^3*s15^2*s23 - 4*s12^2*s15^3*s23 + 3*s12^4*s23^2 + 3*s12^3*s15*s23^2
    + 13*s12^4*s15*s34 + 12*s12^3*s15^2*s34 + 2*s12^2*s15^3*s34
    - 5*s12^4*s23*s34 + 33*s12^3*s15*s23*s34 + 49*s12^2*s15^2*s23*s34
    + 17*s12*s15^3*s23*s34 - 17*s12^3*s23^2*s34 - 19*s12^2*s15*s23^2*s34
    - 5*s12*s15^2*s23^2*s34 - 24*s12^3*s15*s34^2 - 15*s12^2*s15^2*s34^2
    + 2*s12*s15^3*s34^2 + 15*s12^3*s23*s34^2 - 34*s12^2*s15*s23*s34^2
    - 31*s12*s15^2*s23*s34^2 + 2*s15^3*s23*s34^2 + 33*s12^2*s23^2*s34^2
    + 29*s12*s15*s23^2*s34^2 + 5*s15^2*s23^2*s34^2 + 9*s12^2*s15*s34^3
    - 4*s12*s15^2*s34^3 - 15*s12^2*s23*s34^3 + 9*s12*s15*s23*s34^3
    - 4*s15^2*s23*s34^3 - 27*s12*s23^2*s34^3 - 13*s15*s23^2*s34^3
    + 2*s12*s15*s34^4 + 5*s12*s23*s34^4 + 2*s15*s23*s34^4 + 8*s23^2*s34^4
    - 6*s12^3*s15^2*s45 - 9*s12^2*s15^3*s45 - 2*s12*s15^4*s45
    + 30*s12^3*s15*s23*s45 + 56*s12^2*s15^2*s23*s45 + 24*s12*s15^3*s23*s45
    - 12*s12^3*s23^2*s45 - 23*s12^2*s15*s23^2*s45 - 10*s12*s15^2*s23^2*s45
    - 30*s12^3*s15*s34*s45 - 32*s12^2*s15^2*s34*s45 - 6*s12*s15^3*s34*s45
    + 7*s12^3*s23*s34*s45 - 86*s12^2*s15*s23*s34*s45 - 104*s12*s15^2*s23*s34*s45
    - 15*s15^3*s23*s34*s45 + 41*s12^2*s23^2*s34*s45 + 51*s12*s15*s23^2*s34*s45
    + 10*s15^2*s23^2*s34*s45 - 5*s12^3*s34^2*s45 + 33*s12^2*s15*s34^2*s45
    + 14*s12*s15^2*s34^2*s45 - 2*s15^3*s34^2*s45 - 21*s12^2*s23*s34^2*s45
    + 62*s12*s15*s23*s34^2*s45 + 28*s15^2*s23*s34^2*s45 - 46*s12*s23^2*s34^2*s45
    - 28*s15*s23^2*s34^2*s45 + 10*s12^2*s34^3*s45 - s12*s15*s34^3*s45
    + 4*s15^2*s34^3*s45 + 21*s12*s23*s34^3*s45 - 6*s15*s23*s34^3*s45
    + 17*s23^2*s34^3*s45 - 5*s12*s34^4*s45 - 2*s15*s34^4*s45 - 7*s23*s34^4*s45
    - 6*s12^2*s15^2*s45^2 - 5*s12*s15^3*s45^2 - 2*s15^4*s45^2
    - 28*s12^2*s15*s23*s45^2 - 42*s12*s15^2*s23*s45^2 - 10*s15^3*s23*s45^2
    + 9*s12^2*s23^2*s45^2 + 10*s12*s15*s23^2*s45^2 + 24*s12^2*s15*s34*s45^2
    + 36*s12*s15^2*s34*s45^2 + 10*s15^3*s34*s45^2 - 11*s12^2*s23*s34*s45^2
    + 31*s12*s15*s23*s34*s45^2 + 25*s15^2*s23*s34*s45^2
    - 18*s12*s23^2*s34*s45^2 - 10*s15*s23^2*s34*s45^2 + 4*s12^2*s34^2*s45^2
    - 29*s12*s15*s34^2*s45^2 - 17*s15^2*s34^2*s45^2 + 27*s12*s23*s34^2*s45^2
    + 2*s15*s23*s34^2*s45^2 + 9*s23^2*s34^2*s45^2 - 3*s12*s34^3*s45^2
    + 10*s15*s34^3*s45^2 - 16*s23*s34^3*s45^2 - s34^4*s45^2 + 6*s12*s15^2*s45^3
    + 3*s15^3*s45^3 + 8*s12*s15*s23*s45^3 + 10*s15^2*s23*s45^3
    - 8*s12*s15*s34*s45^3 - 10*s15^2*s34*s45^3 + 9*s12*s23*s34*s45^3
    + s12*s34^2*s45^3 + 8*s15*s34^2*s45^3 - 9*s23*s34^2*s45^3 - s34^3*s45^3
    - s15^2*s45^4 + s15*s34*s45^4;
  poly g = 4*s12*s15*(s12 + s15 - s34)*(s15 - s23 - s34)*(s12 + s23 - s45)
                                 *(s12 - s34 - s45)*(s12 + s15 - s34 - s45)*s45;

  partfrac pf = f,g; // pf represents f/g

  print(pf);
  displaypfd(pf);
  checkpfd(list(f,g),pf);

  print(pf+pf);

  print(pf^2);
}

static proc equalpfd2(partfrac2 pf1, partfrac2 pf2)
{
  pf2 = negpfd2(pf2);
  partfrac2 pf;
  pf.terms = mergepfd(pf1.terms,pf2.terms);
  return(checkpfd(list(poly(0),poly(1)), pf)); // test if difference is zero
}

static proc notequalpfd2(partfrac pf1, partfrac pf2)
{
  return(not(equalpfd2(pf1,pf2)));
}

static proc addpfd2(partfrac2 pf1, partfrac2 pf2)
{
  partfrac2 pf;
  pf.terms = mergepfd(pf1.terms,pf2.terms);
  if(doLinearDependencyRemoval)
    {pf.terms = removeLinDepend(pf.terms, denominator_factors);}
  return(pf);
}

static proc negpfd2(partfrac2 pf)
{
  partfrac2 minuspf;
  minuspf.terms = pf.terms;
  int n = size(minuspf.terms);
  for(int i=1; i<=n; i++)
  {
    minuspf.terms[i][1] = -minuspf.terms[i][1];
  }
  return(minuspf);
}

static proc subpfd2(partfrac2 pf1, partfrac2 pf2)
{
  return(addpfd2(pf1,negpfd2(pf2)));
}

static proc multpfd2(partfrac2 pf1, partfrac2 pf2)
{
  list times; int tt=rtimer;
  int sizeq = size(denominator_factors);
  int n1,n2 = size(pf1.terms),size(pf2.terms);
  if(n1==0 || n2==0) {partfrac2 pf; pf.terms = list(); return(pf);}
  int i,j,k,l;
  list terms;
  list t1,t2,newterm;
  intvec indices;
  for(i=1; i<=n1; i++)
  {
    for(j=1; j<=n2; j++)
    {
      t1 = pf1.terms[i];
      t2 = pf2.terms[j];
      newterm[1] = t1[1] * t2[1];
      newterm[2] = intvec(0:0);
      newterm[3] = intvec(0:0);
      indices = 0:sizeq;
      for(k=1; k<=size(t1[2]); k++)
      {
        indices[t1[2][k]]=t1[3][k];
      }
      for(k=1; k<=size(t2[2]); k++)
      {
        indices[t2[2][k]]=indices[t2[2][k]]+t2[3][k];
      }
      l = 0;
      for(k=1; k<=sizeq; k++)
      {
        if(indices[k]>0)
        {
          l++;
          newterm[2][l]=k;
          newterm[3][l]=indices[k];
        }
      }
      terms = mergepfd(terms, list(newterm));
    }
  }
  times[size(times)+1] = rtimer-tt; dbprint(sprintf("building product terms: %sms",rtimer-tt)); tt=rtimer;

  // apply pfd to the list of product terms:
  partfrac2 pf;
  if(ignore_nonlinear_factors)
  {
    indices=0:0;
    for(i=1;i<=size(denominator_factors);i++)
      {indices[i]=(deg(denominator_factors[i])>1);}
    list part_terms; // terms partitioned by nonlinear factors
    intvec I,E;
    list nonlin_fact;
    for(i=1;i<=size(terms);i++)
    {
      I = 0:0;
      E = 0:0;
      for(j=1;j<=size(terms[i][2]);j++)
      {
        k = terms[i][2][j];
        if(indices[k]) // denominator_factors[terms[i][2][j]] is nonlinear
        {
          I[size(I)+1] = k;
          E[size(E)+1] = terms[i][3][j];
          terms[i][2] = delete(terms[i][2],j);
          terms[i][3] = delete(terms[i][3],j);
          continue;
        }
      }

      k = find_entry(nonlin_fact, list(I,E)); // assumes I to be sorted !

      if(k==0)
      {
        k = size(nonlin_fact) + 1;
        nonlin_fact[k] = list(I,E);
        part_terms[k] = list(denominator_factors,list(terms[i]));
      }
      else
      {
        part_terms[k][2][size(part_terms[k][2])+1] = terms[i];
      }
    }

    times[size(times)+1] = rtimer-tt; dbprint(sprintf("extracting nonlinear factors: %sms",rtimer-tt)); tt=rtimer;
    list results;
    if(parallelize_partfrac_multiplication)
      {results = parallelWaitAll("main_part_of_pfd_parallel",part_terms);}
    else
    {
      for(i=1;i<=size(part_terms);i++)
        {results[i] = main_part_of_pfd(denominator_factors,terms,0,0,link(""))[2];}
    }
    times[size(times)+1] = rtimer-tt; dbprint(sprintf("pfd: %sms",rtimer-tt)); tt=rtimer;

    pf.terms = list();
    list newterms;
    for(i=1; i<=size(results); i++)
    {
      newterms = results[i];
      I=nonlin_fact[i][1];
      E=nonlin_fact[i][2];
      k = size(I);
      for(j=1;j<=size(newterms);j++)
      {
        l = size(newterms[j][2]);
        indices = newterms[j][2];
        if(k==1) {indices[l+1] = I[1];}
        else {indices[l+1..l+k] = I;}
        newterms[j][2] = indices;
        indices = newterms[j][3];
        if(k==1) {indices[l+1] = E[1];}
        else {indices[l+1..l+k] = E;}
        newterms[j][3] = indices;
      }
      newterms = sort_indices(newterms);
      pf.terms = mergepfd(pf.terms,newterms);
    }
    times[size(times)+1] = rtimer-tt; dbprint(sprintf("adding nonlinear factors back in: %sms",rtimer-tt)); tt=rtimer;
  }
  else
  {
    pf.terms = main_part_of_pfd(denominator_factors,terms,0,0,link(""))[2];
    times[size(times)+1] = rtimer-tt; dbprint(sprintf("pfd: %sms",rtimer-tt));
  }
  if(size(pf.terms)==0) {pf.terms[1] = list(poly(0),intvec(0:0),intvec(0:0));}
  if(debug_mode) {return(pf,times);}
  return(pf);
}

static proc powpfd2(partfrac2 pf, int n)
{
  if(n<0)  {pf = invpfd2(pf); n=-n;}
  if(n==0) {return(partfrac2(poly(1),poly(1)));}
  if(n==1) {return(pf);}
  partfrac2 tmp = powpfd2(pf, n div 2);
  if(n mod 2==0) {return(multpfd2(tmp,tmp));}
  else {return(multpfd2(multpfd2(tmp,tmp),pf));}
}

static proc divpfd2(partfrac2 pf1, partfrac2 pf2)
{
  return(multpfd2(pf1,invpfd2(pf2)));
}

static proc invpfd2(partfrac2 pf)
{
  poly num,den = numdenompfd2(pf);
  if(num==0) {ERROR("division by zero");}
  return(makepfd2(den,num));
}

static proc getTermpfd2(partfrac2 pf, int i)
{
  return(pf.terms[i]);
}

static proc sizepfd2(partfrac2 pf)
{
  return(size(pf.terms));
}

static proc matchq(ideal q_in, list terms, int normalize)
{
  int nq=size(q_in);
  if(nq==0) {return(pf);}
  int i,j;

  poly p;
  number c1,c2;
  list constants;
  int b=0;
  intvec ind;
  for(i=1; i<=nq; i++)
  {
    if(normalize) // make entries of q_in unique if nessecary:
    {
      p = q_in[i];
      c1 = leadcoef(p); p=p/c1;
      c2 = content(p); p=p/c2;
      constants[i] = c1*c2;
      if(constants[i]!=1) //q_in[i] has to be changed
        {q_in[i] = p; b=1;}
      j = find_entry(q_in,p);
      if(j<i)
        {ERROR("The " + string(j) + "-th and " + string(i)
                            + "-th denominator factor are linearly dependent");}
    }
    j = find_entry(denominator_factors,q_in[i]);
    if(j==0)
    {
      if(autoexpand) {addq(q_in[i]); j=size(denominator_factors);}
      else {ERROR("unknown denominator factor");}
    }
    ind[i] = j;
  }

  if(b) // q_in was changed
  {
    for(i=1;i<=size(terms);i++)
    {
      c1 = number(1);
      for(j=1;j<=size(terms[i][2]);j++)
      {
        c1 = c1*constants[terms[i][2][j]]^terms[i][3][j];
      }
      terms[i][1] = terms[i][1]/c1; // pull constants into numerator
    }
  }

  // change indices in each denominator:
  intvec e;
  list l;
  for(i=1; i<=size(terms); i++)
  {
    for(j=1; j<=size(terms[i][2]); j++)
      {terms[i][2][j]=ind[terms[i][2][j]];}
  }
  terms = sort_indices(terms);

  return(terms);
}

static proc numpfd2(partfrac2 pf)
{
  list terms = pf.terms;

  if(size(terms)==0) {return(poly(0));}
  int m = size(denominator_factors);
  if(m==0) {return(terms[1][1]);}

  int jmax,j,ind,k;
  intvec e_max = 0:m;
  int imax = size(terms);
  for(int i=1; i<=imax; i++)
  {
    jmax = size(terms[i][2]);
    for(j=1; j<=jmax; j++)
    {
      ind = terms[i][2][j];
      e_max[ind] = max(e_max[ind],terms[i][3][j]);
    }
  }
  poly num;
  poly sum_of_numerators = 0;
  intvec e;
  for(i=1; i<=imax; i++)
  {
    e = e_max;
    jmax = size(terms[i][2]);
    for(j=1; j<=jmax; j++)
    {
      ind = terms[i][2][j];
      e[ind] = e[ind]-terms[i][3][j];
    }
    num = terms[i][1];
    for(j=1; j<=m; j++)
      {num = num * denominator_factors[j]^(e[j]);}
    sum_of_numerators = sum_of_numerators + num;
  }

  return(sum_of_numerators);
}

static proc denompfd2(partfrac2 pf)
{
  list terms = pf.terms;

  int m = size(denominator_factors);
  if( size(terms)==0 || m==0) {return(poly(1));}

  int jmax,j,ind;
  intvec e_max=0:m;
  int imax = size(terms);
  for(int i=1; i<=imax; i++)
  {
    jmax = size(terms[i][2]);
    for(j=1; j<=jmax; j++)
    {
      ind = terms[i][2][j];
      e_max[ind] = max(e_max[ind],terms[i][3][j]);
    }
  }

  poly den = 1;
  for(i=1; i<=m; i++)
  {
    den = den * denominator_factors[i]^e_max[i];
  }
  return(den);
}

static proc numdenompfd2(partfrac2 pf)
{
  list terms = pf.terms;

  if(size(terms)==0) {return(poly(0),poly(1));}
  int m = size(denominator_factors);
  if(m==0) {return(terms[1][1],poly(1));}

  int jmax,j,ind,k;
  intvec e_max=0:m;
  int imax = size(terms);
  for(int i=1; i<=imax; i++)
  {
    jmax = size(terms[i][2]);
    for(j=1; j<=jmax; j++)
    {
      ind = terms[i][2][j];
      e_max[ind] = max(e_max[ind],terms[i][3][j]);
    }
  }
  poly num;
  poly sum_of_numerators = 0;
  intvec e;
  for(i=1; i<=imax; i++)
  {
    e = e_max;
    jmax = size(terms[i][2]);
    for(j=1; j<=jmax; j++)
    {
      ind = terms[i][2][j];
      e[ind] = e[ind]-terms[i][3][j];
    }
    num = terms[i][1];
    for(j=1; j<=m; j++)
      {num = num * denominator_factors[j]^(e[j]);}
    sum_of_numerators = sum_of_numerators + num;
  }

  poly den = 1;
  for(i=1; i<=m; i++)
  {
    den = den * denominator_factors[i]^e_max[i];
  }

  return(sum_of_numerators,den);
}

static proc degpfd2(partfrac2 pf)
{
  int d=-1;
  for(int i=1; i<=size(pf.terms); i++)
  {
    d = max(d,deg(pf.terms[i][1]));
  }
  return(d);
}


// partial fractioning algorithm ///////////////////////////////////////////////

proc pfd(list #)
"USAGE:   pfd(f,g[,debug]);   f,g poly, debug int
          pfd(f,g[,debug]);   f poly, g list, debug int
          pfd(arguments[, parallelize]);     arguments list, parallelize int
RETURN:   a partial fraction decomposition of f/g as a list @code{l} where
          @code{l[1]} is an ideal generated by irreducible polynomials and
          @code{l[2]} is a list of fractions.
          Each fraction is represented by a list of
       @* 1) the numerator polynomial
       @* 2) an intvec of indices @code{i} for which @code{l[1][i]} occurs
             as a factor in the denominator
       @* 3) an intvec containing the exponents of those irreducible factors.
       @* Setting @code{debug} to a positive integer measures runtimes and
          creates a log file (default: @code{debug=0}).
       @* The denominator g can also be given in factorized form as a list of
          an ideal of irreducible non constant polynomials and an intvec of
          exponents. This can save time since the first step in the algorithm is
          to factorize g. (A list of the zero-ideal and an empty intvec
          represents a denominator of 1.)
       @* If instead of f and g, the input is a single list (or even a list of
          lists) containing elements of the form @code{list(f,g[,debug])}
          (@code{f,g,debug} as above), the algorithm is applied to all entries
          in parallel (using @ref{parallel_lib}), if @code{parallelize=1}
          (default) and in sequence if @code{parallelize=0}. A list (or list of
          lists) of the results is returned.
NOTE:     The result depends on the monomial ordering. For \"small\" results
          use @code{dp}.
SEE ALSO: checkpfd, evaluatepfd, displaypfd, displaypfd_long, pfdMat
EXAMPLE:  example pfd; shows an example"
{
  short = 0;
  int i,t1;
  if(typeof(#[1])=="list")
  {
    if(size(#)>1)
    {
      if(typeof(#[2])=="list")
        {list arguments = #;    int parallelize = 1;}
      else{if(typeof(#[2])=="int")
        {list arguments = #[1]; int parallelize = #[2];}
      else {ERROR("wrong type for second argument, expected int");}}
    }
    if(parallelize)
    {
      for(i=1; i<=size(arguments); i++)
      {
        if(typeof(arguments[i][1])=="list") //input is list of lists
          {arguments[i] = list(arguments[i],1);}
      }
      return(parallelWaitAll("pfd",arguments));
    }
    else
    {
      list results;
      for(i=1; i<=size(arguments); i++)
      {
        if(typeof(arguments[i][1])=="list") //input is list of lists
          {results[i] = pfd(arguments[i],0);}
        else
        {
          if(size(arguments[i])==2)
            {results[i] = pfd(arguments[i][1],arguments[i][2]);}
          else{if(size(arguments[i])==3)
            {results[i] = pfd(arguments[i][1],arguments[i][2],arguments[i][3]);}
          else {ERROR("wrong number of arguments, expected 2 or 3");}}
        }
      }
      return(results);
    }
  }
  poly f = #[1];
  if(typeof(#[2])=="list")
  {
    list g=#[2];
  }
  else
  {
    poly g=#[2];
  }

  int debug=0; link l=":w ";
  if(size(#)>3) {ERROR("wrong number of arguments, expected 2 or 3");}
  if(size(#)==3)
  {
    debug=#[3];
    l=":a "+string(debug)+"_log_"+datetime()+".txt";
    system("--ticks-per-sec",1000);
  }
  if(debug)
  {
    fprintf(l,"debug: %s", debug);
    fprintf(l,"size(string(f)) = %s, size(string(g)) = %s %n",
               size(string(f)), size(string(g)), 0);
  }

  if(f==0)
  {
    list dec = list(ideal(),list(list(poly(0),intvec(0:0),intvec(0:0))));
    if(debug)
      {fprintf(l,"%ntotal: 0 ms (numerator was 0)",0); close(l);}
    if(voice<=printlevel) {displaypfd(dec);}
    return(dec);
  }
  if(typeof(g)=="poly")
  {
    if(deg(g)==0)
    {
      list dec = list(ideal(),list(list(f/g,intvec(0:0),intvec(0:0))));
      if(debug)
        {fprintf(l,"%ntotal: 0 ms (denominator was constant)",0); close(l);}
      if(voice<=printlevel) {displaypfd(dec);}
      return(dec);
    }

    // (1) factorization of the denominator ////////////////////////////////////
    if(debug) {t1 = rtimer; write(l,"factorizing ");}
    list factor = factorize(g);
    number lcoeff;
    for(i=2; i<=size(factor[1]); i++)
    {
      lcoeff = leadcoef(factor[1][i]);
      factor[1][i] = factor[1][i]/lcoeff;
      factor[1][1] = factor[1][1]*(lcoeff^factor[2][i]); // polynomial is monic (thus unique)
      lcoeff = content(factor[1][i]);
      factor[1][i] = factor[1][i]/lcoeff;
      factor[1][1] = factor[1][1]*(lcoeff^factor[2][i]); // polynomial has nice coefficients
    }
    ideal q = factor[1];
    f = f/q[1];
    q=delete(q,1);
    intvec e = factor[2]; e=delete(e,1);
    int m = size(q);
    if(debug) {t1 = rtimer-t1; fprintf(l,"done! (%s ms)", t1);}
  }
  else{if(typeof(g)=="list")
  {
    if(size(g[1])==0)
    {
      list dec = list(ideal(),list(list(f,intvec(0:0),intvec(0:0))));
      if(debug)
        {fprintf(l,"%ntotal: 0 ms (denominator was constant)",0); close(l);}
      if(voice<=printlevel) {displaypfd(dec);}
      return(dec);
    }

    // denominator is already factorized
    for(i=1;i<=size(g[1]);i++)
    {
      if(size(factorize(g[1][i])[1])>2)
        {ERROR("factors should be irreducible");}
    }

    ideal q = g[1];
    intvec e = g[2];
    int m = size(q);
  }
  else
  {ERROR("wrong type for second argument, expected poly or list(ideal,intvec)");}}

  list terms = list(list(poly(f),1..m,e));
  list dec = main_part_of_pfd(q,terms,t1,debug,l);
  if(voice<=printlevel) {displaypfd(dec);}
  return(dec);
}
example
{
  "EXAMPLE:";
  echo=voice;
  ring R = 0,(x,y),dp;
  poly f = x^3+3*x^2*y+2*y^2-x^2+4*x*y;
  poly g = x^2*y*(x-1)*(x-y)^2;

  list dec = pfd(f,g);

  displaypfd_long(dec);   // display result
  checkpfd(list(f,g),dec);   // check for equality to f/g

  // calculate decompositions of a 2x2 matrix of rational functions at once:
  list arguments = list(list(f, g),          list(1, f)     ),
                        list(list(x*y, y+1), list(1, x^2-y^2));

  dec = pfd(arguments);

  // the result has the same shape as the
  // input (2x2 matrix as list of lists):
  displaypfd_long(dec[1][1]);
  displaypfd_long(dec[1][2]);
  displaypfd_long(dec[2][1]);
  displaypfd_long(dec[2][2]);

  // a more complicated example
  ring S = 0,(s12,s15,s23,s34,s45),dp;
  poly f = 7*s12^4*s15^2 + 11*s12^3*s15^3 + 4*s12^2*s15^4 - 10*s12^4*s15*s23
    - 14*s12^3*s15^2*s23 - 4*s12^2*s15^3*s23 + 3*s12^4*s23^2 + 3*s12^3*s15*s23^2
    + 13*s12^4*s15*s34 + 12*s12^3*s15^2*s34 + 2*s12^2*s15^3*s34
    - 5*s12^4*s23*s34 + 33*s12^3*s15*s23*s34 + 49*s12^2*s15^2*s23*s34
    + 17*s12*s15^3*s23*s34 - 17*s12^3*s23^2*s34 - 19*s12^2*s15*s23^2*s34
    - 5*s12*s15^2*s23^2*s34 - 24*s12^3*s15*s34^2 - 15*s12^2*s15^2*s34^2
    + 2*s12*s15^3*s34^2 + 15*s12^3*s23*s34^2 - 34*s12^2*s15*s23*s34^2
    - 31*s12*s15^2*s23*s34^2 + 2*s15^3*s23*s34^2 + 33*s12^2*s23^2*s34^2
    + 29*s12*s15*s23^2*s34^2 + 5*s15^2*s23^2*s34^2 + 9*s12^2*s15*s34^3
    - 4*s12*s15^2*s34^3 - 15*s12^2*s23*s34^3 + 9*s12*s15*s23*s34^3
    - 4*s15^2*s23*s34^3 - 27*s12*s23^2*s34^3 - 13*s15*s23^2*s34^3
    + 2*s12*s15*s34^4 + 5*s12*s23*s34^4 + 2*s15*s23*s34^4 + 8*s23^2*s34^4
    - 6*s12^3*s15^2*s45 - 9*s12^2*s15^3*s45 - 2*s12*s15^4*s45
    + 30*s12^3*s15*s23*s45 + 56*s12^2*s15^2*s23*s45 + 24*s12*s15^3*s23*s45
    - 12*s12^3*s23^2*s45 - 23*s12^2*s15*s23^2*s45 - 10*s12*s15^2*s23^2*s45
    - 30*s12^3*s15*s34*s45 - 32*s12^2*s15^2*s34*s45 - 6*s12*s15^3*s34*s45
    + 7*s12^3*s23*s34*s45 - 86*s12^2*s15*s23*s34*s45 - 104*s12*s15^2*s23*s34*s45
    - 15*s15^3*s23*s34*s45 + 41*s12^2*s23^2*s34*s45 + 51*s12*s15*s23^2*s34*s45
    + 10*s15^2*s23^2*s34*s45 - 5*s12^3*s34^2*s45 + 33*s12^2*s15*s34^2*s45
    + 14*s12*s15^2*s34^2*s45 - 2*s15^3*s34^2*s45 - 21*s12^2*s23*s34^2*s45
    + 62*s12*s15*s23*s34^2*s45 + 28*s15^2*s23*s34^2*s45 - 46*s12*s23^2*s34^2*s45
    - 28*s15*s23^2*s34^2*s45 + 10*s12^2*s34^3*s45 - s12*s15*s34^3*s45
    + 4*s15^2*s34^3*s45 + 21*s12*s23*s34^3*s45 - 6*s15*s23*s34^3*s45
    + 17*s23^2*s34^3*s45 - 5*s12*s34^4*s45 - 2*s15*s34^4*s45 - 7*s23*s34^4*s45
    - 6*s12^2*s15^2*s45^2 - 5*s12*s15^3*s45^2 - 2*s15^4*s45^2
    - 28*s12^2*s15*s23*s45^2 - 42*s12*s15^2*s23*s45^2 - 10*s15^3*s23*s45^2
    + 9*s12^2*s23^2*s45^2 + 10*s12*s15*s23^2*s45^2 + 24*s12^2*s15*s34*s45^2
    + 36*s12*s15^2*s34*s45^2 + 10*s15^3*s34*s45^2 - 11*s12^2*s23*s34*s45^2
    + 31*s12*s15*s23*s34*s45^2 + 25*s15^2*s23*s34*s45^2
    - 18*s12*s23^2*s34*s45^2 - 10*s15*s23^2*s34*s45^2 + 4*s12^2*s34^2*s45^2
    - 29*s12*s15*s34^2*s45^2 - 17*s15^2*s34^2*s45^2 + 27*s12*s23*s34^2*s45^2
    + 2*s15*s23*s34^2*s45^2 + 9*s23^2*s34^2*s45^2 - 3*s12*s34^3*s45^2
    + 10*s15*s34^3*s45^2 - 16*s23*s34^3*s45^2 - s34^4*s45^2 + 6*s12*s15^2*s45^3
    + 3*s15^3*s45^3 + 8*s12*s15*s23*s45^3 + 10*s15^2*s23*s45^3
    - 8*s12*s15*s34*s45^3 - 10*s15^2*s34*s45^3 + 9*s12*s23*s34*s45^3
    + s12*s34^2*s45^3 + 8*s15*s34^2*s45^3 - 9*s23*s34^2*s45^3 - s34^3*s45^3
    - s15^2*s45^4 + s15*s34*s45^4;
  poly g = 4*s12*s15*(s12 + s15 - s34)*(s15 - s23 - s34)*(s12 + s23 - s45)
                                 *(s12 - s34 - s45)*(s12 + s15 - s34 - s45)*s45;

  list dec = pfd(f,g);

  displaypfd(dec);
  checkpfd(list(f,g),dec);

  // size comparison:
  size(string(f)) + size(string(g));
  size(getStringpfd(dec));
}

static proc main_part_of_pfd(ideal q, reference terms, int t1, debug, link l)
{
  int counter,tt,ttt,i;

  if(size(terms)==0) {return(list(q,list()));}
  // (2) Nullstellensatz decomposition /////////////////////////////////////////
  if(debug)
    {int t2 = rtimer; write(l,"Nullstellensatz decomposition ");}
  list dec,newterms,result;
  int imax;
  while(size(terms)>0)
  {
    if(debug) {ttt = rtimer; counter++;}
    imax = size(terms);
    newterms = list();
    for(i=1; i<=imax; i++)
    {
      result = NSSdecompStep(terms[i],q);
      if(size(result)>1) {newterms = mergepfd(newterms, result);}
      else                    {dec = mergepfd(dec,      result);}
    }
    terms = newterms;
    if(debug)
      {fprintf(l,"  %s: %s ms, %s terms, %s unfinished",
       counter, rtimer-ttt, size(terms)+size(dec), size(terms));}
  }
  if(debug)
    {t2 = rtimer-t2; fprintf(l,"done! (%s ms, %s terms)", t2, size(dec));}

  // (3) short numerator decomposition /////////////////////////////////////////
  if(debug)
    {int t3 = rtimer; write(l,"short numerator decompositions "); counter=0;}
  terms = dec;
  dec = list();
  while(size(terms)>0)
  {
    if(debug) {tt = rtimer; counter++;}
    imax = size(terms);
    newterms = list();
    for(i=1; i<=imax; i++)
    {
      result = shortNumeratorDecompStep(terms[i],q,debug,l);

      if(debug) {ttt = rtimer;}
      newterms = mergepfd(newterms, result[1]);
      dec = mergepfd(dec, result[2]);
      if(debug)
        {fprintf(l,"      merging: %s ms, %s new terms",
         rtimer-ttt, size(result[1]));}
    }
    terms = newterms;
    if(debug)
      {fprintf(l,"  %s: %s ms, %s terms, %s unfinished",
       counter, rtimer-tt, size(terms)+size(dec), size(terms));}
  }
  if(debug)
    {t3 = rtimer-t3; fprintf(l,"done! (%s ms, %s terms)", t3, size(dec));}

  // (4) algebraic dependence decomposition ////////////////////////////////////
  if(debug)
    {int t4 = rtimer; write(l,"algebraic dependence decomposition "); counter=0;}
  terms = dec;
  dec = list();
  while(size(terms)>0)
  {
    if(debug) {tt = rtimer; counter++;}
    imax = size(terms);
    newterms = list();
    for(i=1; i<=imax; i++)
    {
      result = algDependDecompStep(terms[i],q,debug,l);

      if(debug) {ttt = rtimer;}
      if(size(result)>1) {newterms = mergepfd(newterms, result);}
      else                    {dec = mergepfd(dec,      result);}
      if(debug)
        {fprintf(l,"      merging: %s ms, %s new terms", rtimer-ttt, size(result));}
    }
    terms = newterms;
    if(debug)
      {fprintf(l,"  %s: %s ms, %s terms, %s unfinished",
       counter, rtimer-tt, size(terms)+size(dec),size(terms));}
  }
  if(debug)
    {t4 = rtimer-t4; fprintf(l,"done! (%s ms, %s terms)", t4, size(dec));}

  // (5) numerator decomposition ///////////////////////////////////////////////
  if(debug)
    {int t5 = rtimer; write(l,"numerator decompositions "); counter=0;}
  terms = dec;
  dec = list();
  while(size(terms)>0)
  {
    if(debug) {tt = rtimer; counter++;}
    imax = size(terms);
    newterms = list();
    for(i=1; i<=imax; i++)
    {
      result = numeratorDecompStep(terms[i],q,debug,l);

      if(debug) {ttt = rtimer;}
      newterms = mergepfd(newterms, result[1]);
      dec = mergepfd(dec, result[2]);
      if(debug)
        {fprintf(l,"      merging: %s ms, %s new terms", rtimer-ttt, size(result[1]));}
    }
    terms = newterms;
    if(debug)
      {fprintf(l,"  %s: %s ms, %s terms, %s unfinished",
       counter, rtimer-tt, size(terms)+size(dec), size(terms));}
  }
  if(debug)
    {t5 = rtimer-t5; fprintf(l,"done! (%s ms, %s terms)", t5, size(dec));}

  // (6) remove linear dependencies ////////////////////////////////////////////
  if(doLinearDependencyRemoval)
  {
    if(debug)
      {int t6 = rtimer; write(l,"eliminating linear dependent terms "); counter=0;}
    dec = removeLinDepend(dec,q,debug,l); // eliminate linear dependent terms
    if(debug)
      {t6 = rtimer-t6; fprintf(l,"done! (%s ms, %s terms)", t6, size(dec));}
  }

  if(size(dec)==1) {if(dec[1][1]==0) {dec = list();}}
  dec = list(q,dec);
  if(debug) {fprintf(l,"%ntotal: %s ms", t1+t2+t3+t4+t5+t6); close(l);}
  return(dec);
}

static proc NSSdecompStep(list l, ideal q)
{
  poly f=l[1];
  intvec indices=l[2];
  intvec e=l[3];
  int m = size(indices);

  if(m==0) // denominator is 1
    {return(list(l));} // do nothing, return input

  ideal qe = q[indices];
  for(int i=1; i<=m; i++)
    {qe[i] = qe[i]^e[i];}
  matrix T;
  ideal qe_std = liftstd(qe,T);

  if(deg(qe_std) == 0)
  {
    T = T/qe_std[1];
      // now 1 = T[1,1]*qe[1] + ... + T[m,1]*qe[m] is a Nullstellensatz certificate
    list dec;
    poly h;
    for(i=1; i<=m; i++)
    {
      h = T[i,1];
      if(h != 0)
        {dec[size(dec)+1] = list(f*h,delete(indices,i),delete(e,i));}
    }
    return(dec);
  }
  else
  {
    return(list(l)); // do nothing, return input
  }
}

static proc shortNumeratorDecompStep(list l, ideal q, list #)
{
  int debug=0;
  if(size(#)>0) {debug=#[1]; link ll=#[2];}
  if(debug) {system("--ticks-per-sec",1000); int tt=rtimer;}

  poly f=l[1];
  intvec indices=l[2];
  intvec e=l[3];
  int m = size(indices);

  if(m==0) // denominator is 1
  {
    if(debug)
      {fprintf(ll,"      shortNumeratorDecompStep: %s ms (m=%s, e=%s) "
                    +"--> constant denominator", rtimer-tt, m, e);}
    return(list(list(),list(l))); // do nothing, return input
  }

  ideal q_denom = q[indices]; // factors occuring in the denominator
  matrix T;
  ideal q_std = liftstd(q_denom,T);
  list divrem = division(f,q_std);
  poly r = divrem[2][1]/divrem[3][1,1];

  if(r!=0)
  {
    if(debug)
      {fprintf(ll,"      shortNumeratorDecompStep: %s ms (m=%s, e=%s) "
                  +"--> remainder is nonzero", rtimer-tt, m, e);}
    return(list(list(),list(l))); // if there is a rest, decomposing further would
  }                               // not help in the next step (alg. depend. decomposition)

  matrix a = divrem[1]/divrem[3][1,1]; // now f = r + a[1,1]*q_std[1] + ... +a[m,1]*q_std[m]
  a = T*a;   // lift coefficients   ==>   now f = r + a[1,1]*q[1]     + ... +a[m,1]*q[m]

  // reduce w.r.t. groebner basis of syz(q) to make the numerators "smaller":
  vector v;
  for(int i=1; i<=m; i++) {v = v + gen(i)*a[i,1];}
  v = reduce(v, std(syz(q_denom)));

  list fraction,dec;
  for(i=1; i<=m; i++)
  {
    if(v[i] == 0)
    {
      i++;
      continue;
    }
    fraction[1] = v[i];
    if(e[i]==1)
      {
        fraction[2] = delete(indices,i);
        fraction[3] = delete(e,i);
      }
    else
    {
      fraction[2] = indices;
      fraction[3] = e;
      fraction[3][i] = fraction[3][i] - 1;
    }
    dec[size(dec)+1] = fraction;
  }

  if(debug)
    {fprintf(ll,"      shortNumeratorDecompStep: %s ms (m=%s, e=%s, deg(v)=%s, size(v)=%s)",
     rtimer-tt, m, e, deg(v), size(v));}
  return(list(dec,list()));
}

static proc algDependDecompStep(list l, ideal q, list #)
{
  int debug=0;
  if(size(#)>0) {debug=#[1]; link ll=#[2];}
  if(debug) {system("--ticks-per-sec",1000); int tt=rtimer;}
  def br = basering;
  int d = nvars(br);
  intvec indices=l[2];
  int m = size(indices);
  intvec e=l[3];
  int i;

  if(m==0) // denominator is 1
  {
    if(debug)
      {fprintf(ll,"      algDependDecompStep: %s ms (m=%s, e=%s)", rtimer-tt, m, e);}
    return(list(l)); // do nothing, return input
  }

  if(m<=d)
  {
    if(size(syz(module(transpose(jacob(ideal(q[indices]))))))==0) // jacobian criterion
    {
      if(debug)
        {fprintf(ll,"      algDependDecompStep: %s ms (m=%s, e=%s) "
                    +"--> alg. indep.", rtimer-tt, m, e);}
      return(list(l)); // do nothing, return input
    }
  }

  def R = changeord(list(list("dp",m+d)),extendring(m, "y(", "dp", 1, changevar("x()",br)));
  setring(R);

  list l = fetch(br,l);
  ideal q = fetch(br,q);
  poly f=l[1];

  ideal I;
  for(i=1; i<=m; i++)
    {I[i] = y(i)-q[indices[i]];}

  ideal annihilatingPolys = eliminate(I,intvec(1..d));

  poly g = annihilatingPolys[1];

  poly tail = g[size(g)];    // term of lowest dp-order (thus lowest degree)
  number tcoeff = leadcoef(tail);
  intvec texpon = leadexp(tail);
  texpon = texpon[(d+1)..(d+m)];
  g = g-tail;
  poly term;
  number coeff;
  intvec expon;
  list fraction,dec;
  int pow;
  int jmax = size(g);
  for(int j=1; j<=jmax; j++)
  {
    term = g[j];
    coeff = leadcoef(term);
    expon = leadexp(term);
    expon = expon[(d+1)..(d+m)];
    fraction[1] = -f*coeff/tcoeff;
    fraction[2] = intvec(0:0);
    fraction[3] = intvec(0:0);
    for(i=1; i<=m; i++)
    {
      pow = expon[i]-texpon[i]-e[i];
      if(pow>=0)
      {
        fraction[1] = fraction[1]*q[indices[i]]^pow;
      }
      else
      {
        fraction[2][size(fraction[2])+1] = indices[i];
        fraction[3][size(fraction[3])+1] = -pow;
      }
    }
    dec[size(dec)+1] = fraction;
  }
  setring(br);
  list dec = fetch(R,dec);
  if(debug)
    {fprintf(ll,"      algDependDecompStep: %s ms (m=%s, e=%s)", rtimer-tt, m, e);}
  return(dec);
}

static proc numeratorDecompStep(list l, ideal q, list #)
{
  int debug=0;
  if(size(#)>0) {debug=#[1]; link ll=#[2];}
  if(debug) {system("--ticks-per-sec",1000); int tt=rtimer;}

  poly f=l[1];
  intvec indices=l[2];
  intvec e=l[3];
  int m = size(indices);

  if(m==0) // denominator is 1
  {
    if(debug)
      {fprintf(ll,"      numeratorDecompStep: %s ms (m=%s, e=%s) "
                  +"--> constant denominator", rtimer-tt, m, e);}
    return(list(list(),list(l))); // do nothing, return input
  }

  ideal q_denom = q[indices]; // factors in the denominator
  matrix T;
  ideal q_std = liftstd(q_denom,T);
  list divrem = division(f,q_std);
  matrix a = divrem[1]/divrem[3][1,1];
  poly r = divrem[2][1]/divrem[3][1,1]; // now f = r + a[1,1]*q_std[1] + ... +a[m,1]*q_std[m]
  a = T*a;   // lift coefficients    ==>   now f = r + a[1,1]*q[1]     + ... +a[m,1]*q[m]

  // reduce w.r.t. groebner basis of syz(q) to make the numerators "smaller"
  vector v;
  for(int i=1; i<=m; i++) {v = v + gen(i)*a[i,1];}
  v = reduce(v, std(syz(q_denom)));

  list fraction,dec,rest;
  if(r!=0)
    {rest[1] = list(r,indices,e);}
  for(i=1; i<=m; i++)
  {
    if(v[i] == 0)
    {
      i++;
      continue;
    }
    fraction[1] = v[i];
    if(e[i]==1)
      {
        fraction[2] = delete(indices,i);
        fraction[3] = delete(e,i);
      }
    else
    {
      fraction[2] = indices;
      fraction[3] = e;
      fraction[3][i] = fraction[3][i] - 1;
    }
    dec[size(dec)+1] = fraction;
  }

  if(debug)
    {fprintf(ll,"      numeratorDecompStep: %s ms (m=%s, e=%s, deg(v)=%s, size(v)=%s)",
     rtimer-tt, m, e, deg(v), size(v));}
  return(list(dec,rest));
}

static proc removeLinDepend_old(list terms, ideal q, list #)  // always full evaluation
{
  int debug=0;
  if(size(#)>0) {debug=#[1]; link ll=#[2];}
  if(debug) {system("--ticks-per-sec",1000); int tt=rtimer;}
  int m=size(terms);
  if(m<=1) // max. 1 term ==> no linear dependencies
  {
    if(debug)
       {fprintf(ll,"  no linear dependencies (only 1 term)");}
    return(terms); // do nothing, return input
  }
  int nq = size(q);
  ideal vars=maxideal(1);
  int nvar = nvars(basering);

  // calculate exponent vector for common denominator
  int i,jmax,j,ind,k,l;
  intvec e_max=0:nq;
  for(i=1; i<=m; i++)
  {
    jmax = size(terms[i][2]);
    for(j=1; j<=jmax; j++)
    {
      ind = terms[i][2][j];
      e_max[ind] = max(e_max[ind],terms[i][3][j]);
    }
  }

  // determine number of evaluation points needed for each variable
  list e;
  for(i=1; i<=nvar; i++)
  {
    e[i] = 0:nvar;
    e[i][i] = 1;
  }
  intvec npoints=0:nvar;
  intvec degrees;
  list qdegrees;
  for(i=1; i<=nq; i++)
  {
    qdegrees[i] = 0:nvar;
    for(j=1; j<=nvar; j++)
    {
      qdegrees[i][j] = deg(q[i],e[j]); // degree of q[i] w.r.t. the j-th variable
    }
  }
  int expo;
  list factors;
  for(i=1; i<=m; i++)
  {
    degrees=0:nvar;
    factors[i] = list(1..nq,e_max);
    for(j=1; j<=size(terms[i][2]); j++)
    {
      ind = terms[i][2][j];
      factors[i][2][ind] = e_max[ind] - terms[i][3][j];
    }
    l = nq;
    for(j=1; j<=l; j++)
    {
      if(factors[i][2][j]==0)
      {
        factors[i][1] = delete(factors[i][1], j);
        factors[i][2] = delete(factors[i][2], j);
        l--; continue;
      }
      else
      {
        for(k=1; k<=nvar; k++)
          {degrees[k] = degrees[k] + qdegrees[factors[i][1][j]][k]*factors[i][2][j];}
      }
    }
    for(j=1; j<=nvar; j++)
    {
      npoints[j] = max(npoints[j], degrees[j] + deg(terms[i][1],e[j]));
      //npoints[j] = max(npoints[j],3);
    }
    //print(""); print(i);
    //print("degrees:");
    //print(degrees);
  }
  npoints = npoints + 1; // we need one point more than the degrees for interpolation
  //print("npoints:"); print(npoints);
  if(debug)
  {
    k=1;
    for(i=1; i<=nvar; i++) {k=k*npoints[i];}
    fprintf(ll,"  calculated number of evaluation points needed: %s ms "
    + "(npoints=%s with product %s, e_max=%s)", rtimer-tt, npoints, k,e_max); tt=rtimer;
  }

  //create list of evaluation points
  list evalPoints=list(ideal());
  list newPoints;
  for(i=1; i<=nvar; i++)
  {
    newPoints = list();
    ind = 0;
    for(j=1; j<=size(evalPoints); j++)
    {
      for(k=0; k<npoints[i]; k++)
      {
        ind++;
        newPoints[ind] = evalPoints[j];
        newPoints[ind][i] = k;
      }
    }
    evalPoints = newPoints;
  }
  if(debug) {fprintf(ll,"  created list of evaluation points: %s ms (%s points)",
                                        rtimer-tt, size(evalPoints)); tt=rtimer;}

  // compute n-by-m matrix of evaluations
  int n=size(evalPoints);
  def currRing = basering;
  map evalmap;
  matrix vals[n][m];
  poly p;
  ideal q_eval;
  poly factor;
  if(debug) {int ttt = rtimer;}
  for(i=1; i<=n; i++)
  {
    evalmap = currRing, evalPoints[i];
    for(j=1; j<=nq; j++)
    {
      //q_eval[j] = substitute(q[j],vars,evalPoints[i]);                          // option 1
      p = q[j];                                                                 // option 2 (much faster)
      q_eval[j] = evalmap(p);                                                   // option 2
    }
    for(j=1; j<=m; j++)
    {
      factor = 1;
      l = size(factors[j][1]);
      for(k=1; k<=l; k++)
      {
        factor = factor * (q_eval[factors[j][1][k]])^factors[j][2][k];
        if(factor == 0) {break;}
      }
      //print(terms[j][1]);
      //print("");
      //print(evalPoints[i]);

      //vals[i,j] = factor*substitute(terms[j][1],vars,evalPoints[i]);            // option 1
      p = terms[j][1];                                                          // option 2 (much faster!)
      vals[i,j] = factor*evalmap(p);                                            // option 2
    }
    if(debug)
      {fprintf(ll,"    row %s done: %s ms (evaluation point: %s)",i, rtimer-ttt, evalPoints[i]); ttt=rtimer;}
  }
  if(debug)
    {fprintf(ll,"  created %sx%s matrix of evaluations: %s ms",n,m,rtimer-tt); tt=rtimer;
     write("ssi:w last_eval_matrix.ssi",vals);}

  // determine linear dependencies via Gauss' Algorithm
  //print(vals);

  vals = gauss_row(vals);                                                      //option 1 (~4 times faster for big matrices)
  intvec steps = 0:0; // pivot columns
  for(i=1; i<=n; i++)
  {
    for(j=m; j>=1; j--) {if(vals[i,j] != 0) {break;}}
    if(j==0) {break;} // zero-line --> stop
    steps[i] = j;
  }

  /*if(debug) {ttt=rtimer;}                                                       // option 2
  vals = ludecomp(vals)[3];
  if(debug) {fprintf(ll,"    ludecomp finished: %s ms",rtimer-ttt);ttt=rtimer;}
  j=1;
  intvec steps = 0:0; // pivot columns
  for(i=1; i<=n; i++)
  {
    for(; j<=m; j++)
    {
      if(vals[i,j] != 0)
      {
        vals = multrow(vals,i,1/vals[i,j]);
        for(k=1; k<i; k++)
        {
          if(vals[k,j]!=0) {vals = addrow(vals,i,-vals[k,j],k);}
        }
        break;
      }
    }
    if(j==m+1) {break;} // zero-line --> stop
    steps[i] = j;
  }
  if(debug) {fprintf(ll,"    calculated reduced form: %s ms",rtimer-ttt);}        */


  //print(""); print(vals);
  if(debug) {fprintf(ll,"  applied Gauss' Algorithm: %s ms",rtimer-tt); tt=rtimer;}

  matrix ones=1:m;
  matrix coefficients = vals*ones;
  list newterms;
  ind = 1;
  for(i=1; i<=size(steps); i++)
  {
    if(coefficients[i,1]!=0)
    {
      newterms[ind] = terms[steps[i]];
      //print(i); print(newterms[i]); print(coefficients); print("");
      newterms[ind][1] = newterms[ind][1]*coefficients[i,1];
      ind++;
    }
  }
  if(debug) {fprintf(ll,"  eliminated linear dependencies: %s ms (%s dependencies found)",rtimer-tt,m-size(steps));}

  return(newterms);
}

static proc removeLinDepend(list terms, ideal q, list #)  // evaluation row by row
{
  int debug=0;
  if(size(#)>0) {debug=#[1]; link ll=#[2];}
  if(debug) {system("--ticks-per-sec",1000); int tt=rtimer;}
  int m=size(terms);
  if(m<=1) // max. 1 term ==> no linear dependencies
  {
    if(debug)
       {fprintf(ll,"  no linear dependencies (only 1 term)");}
    return(terms); // do nothing, return input
  }
  int nq = size(q);
  ideal vars=maxideal(1);
  int nvar = nvars(basering);

  // calculate exponent vector for common denominator
  int i,jmax,j,ind,k,l;
  intvec e_max=0:nq;
  for(i=1; i<=m; i++)
  {
    jmax = size(terms[i][2]);
    for(j=1; j<=jmax; j++)
    {
      ind = terms[i][2][j];
      e_max[ind] = max(e_max[ind],terms[i][3][j]);
    }
  }

  // determine number of evaluation points needed for each variable
  list e;
  for(i=1; i<=nvar; i++)
  {
    e[i] = 0:nvar;
    e[i][i] = 1;
  }
  intvec npoints=0:nvar;
  intvec degrees;
  list qdegrees;
  for(i=1; i<=nq; i++)
  {
    qdegrees[i] = 0:nvar;
    for(j=1; j<=nvar; j++)
    {
      qdegrees[i][j] = deg(q[i],e[j]); // degree of q[i] w.r.t. the j-th variable
    }
  }
  int expo;
  list factors;
  for(i=1; i<=m; i++)
  {
    degrees=0:nvar;
    factors[i] = list(1..nq,e_max);
    for(j=1; j<=size(terms[i][2]); j++)
    {
      ind = terms[i][2][j];
      factors[i][2][ind] = e_max[ind] - terms[i][3][j];
    }
    l = nq;
    for(j=1; j<=l; j++)
    {
      if(factors[i][2][j]==0)
      {
        factors[i][1] = delete(factors[i][1], j);
        factors[i][2] = delete(factors[i][2], j);
        l--; continue;
      }
      else
      {
        for(k=1; k<=nvar; k++)
          {degrees[k] = degrees[k] + qdegrees[factors[i][1][j]][k]*factors[i][2][j];}
      }
    }
    for(j=1; j<=nvar; j++)
    {
      npoints[j] = max(npoints[j], degrees[j] + deg(terms[i][1],e[j]));
      //npoints[j] = max(npoints[j],3);
    }
    //print(""); print(i);
    //print("degrees:");
    //print(degrees);
  }
  npoints = npoints + 1; // we need one point more than the degrees for interpolation
  //print("npoints:"); print(npoints);
  if(debug)
  {
    k=1;
    for(i=1; i<=nvar; i++) {k=k*npoints[i];}
    fprintf(ll,"  calculated number of evaluation points needed: %s ms "
    + "(npoints=%s with product %s, e_max=%s)", rtimer-tt, npoints, k,e_max); tt=rtimer;
  }

  //create list of evaluation points
  list evalPoints=list(ideal());
  list newPoints;
  for(i=1; i<=nvar; i++)
  {
    newPoints = list();
    ind = 0;
    for(j=1; j<=size(evalPoints); j++)
    {
      for(k=0; k<npoints[i]; k++)
      {
        ind++;
        newPoints[ind] = evalPoints[j];
        newPoints[ind][i] = k;
      }
    }
    evalPoints = newPoints;
  }
  if(debug) {fprintf(ll,"  created list of evaluation points: %s ms (%s points)",
                                        rtimer-tt, size(evalPoints)); tt=rtimer;}

  // compute n-by-m matrix of evaluations AND simultanously calculate row_echelon form
  system("random",42); // set random number generator starting value
  int n=size(evalPoints);
  def currRing = basering;
  map evalmap;
  matrix vals[m][0]; // will be expanded to m-by-n matrix
  matrix newcol[m][1];
  poly p;
  intvec steps;
  ideal q_eval;
  poly factor;
  if(debug) {int ttt = rtimer;}
  for(i=1; i<=n; i++)
  {
    ind = random(1,n-i+1);
    evalmap = currRing, evalPoints[ind];
    evalPoints = delete(evalPoints,ind);
    for(j=1; j<=nq; j++)
    {
      p = q[j];
      q_eval[j] = evalmap(p);
    }
    for(j=1; j<=m; j++)
    {
      factor = 1;
      l = size(factors[j][1]);
      for(k=1; k<=l; k++)
      {
        factor = factor * (q_eval[factors[j][1][k]])^factors[j][2][k];
        if(factor == 0) {break;}
      }
      //print(terms[j][1]);
      //print("");
      //print(evalPoints[i]);

      p = terms[j][1];
      newcol[j,1] = factor*evalmap(p);
    }
    vals = concat(vals,newcol);

    if(debug)
      {fprintf(ll,"    column %s done: %s ms (evaluation point: %s)",i, rtimer-ttt, evalmap); ttt=rtimer;}

    if(i%batch_size==0 || i==n)
    {
      vals = compress(gauss_col(vals)); // apply gauss and remove zero columns
      steps = 0:0; // pivot rows
      for(j=1; j<=ncols(vals); j++)
      {
        for(k=m; k>=1; k--) {if(vals[k,j] != 0) {break;}}
        if(k==0) {break;} // zero-column --> stop
        steps[j] = k;
      }
      if(debug)
        {fprintf(ll,"    gauss: %s ms (%s columns)",rtimer-ttt, size(steps)); ttt=rtimer;}
      if(size(steps)==m) {break;} // terms are already lin. indep. ==> stop looking for dependencies
    }
  }
  if(debug)
    {fprintf(ll,"  created %sx%s matrix of evaluations and transformed to reduced column form: %s ms",m,min(i,n),rtimer-tt); tt=rtimer;
     write("ssi:w last_eval_matrix.ssi",vals);}

  matrix ones = transpose(1:m);
  matrix coefficients = ones*vals;
  list newterms;
  ind = 1;
  for(i=1; i<=size(steps); i++)
  {
    if(coefficients[1,i]!=0)
    {
      newterms[ind] = terms[steps[i]];
      //print(i); print(newterms[i]); print(coefficients); print("");
      newterms[ind][1] = newterms[ind][1]*coefficients[1,i];
      ind++;
    }
  }
  if(debug) {fprintf(ll,"  eliminated linear dependencies: %s ms (%s dependencies found)",rtimer-tt,m-size(steps));}

  return(newterms);
}

static proc mergepfd(list dec1, list dec2)
{
  // Note: assumes dec1 is already sorted w.r.t. dp in the denominator exponents
  int n1=size(dec1);
  int n2=size(dec2);
  if(n2==0) {return(dec1);}
  int i;
  int a,b,m;
  list entry;
  for(i=1; i<=n2; i++)
  {
    entry = dec2[i];
    if(n1==0)
    {
      dec1=list(entry); n1++;
      i++; continue;
    }

    a=1;
    b=n1;
    m = (a+b) div 2;
    while(b>a)
    {
      if(is_dp_smaller(dec1[m][2], dec1[m][3], entry[2], entry[3]))
      {
        a=m+1;
      }
      else
      {
        b=m;
      }
      m = (a+b) div 2;
    }
    if(is_dp_smaller(dec1[a][2], dec1[a][3], entry[2], entry[3]))
      {dec1=insert(dec1,entry,a); n1++;}
    else{if(entry[2]==dec1[a][2] && entry[3]==dec1[a][3])
    {
      dec1[a][1] = dec1[a][1] + entry[1];   //same denominator: add numerators
      if(dec1[a][1]==0)
        {dec1 = delete(dec1,a); n1--;}
    }
    else
      {dec1=insert(dec1,entry,a-1); n1++;}}
  }
  return(dec1);
}

static proc is_dp_smaller(intvec indices1, intvec e1, intvec indices2, intvec e2)
{
  if(size(e2)==0) {return(0);}
  if(size(e1)==0) {return(1);}
  int s1,s2 = sum(e1),sum(e2);
  if(s1<s2) {return(1);}
  if(s1>s2) {return(0);}
  int n1,n2 = size(indices1),size(indices2);
  int imax = min(n1,n2);
  for(int i=0; i<imax; i++)
  {
    if(indices1[n1-i]>indices2[n2-i]) {return(1);}
    if(indices1[n1-i]<indices2[n2-i]) {return(0);}
    if(e1[n1-i]>e2[n2-i]) {return(1);}
    if(e1[n1-i]<e2[n2-i]) {return(0);}
  }
  return(0);
}

proc checkpfd(list fraction, def dec, list #)
"USAGE:   checkpfd(list(f,g),dec[,N,C]);   f,g poly, dec list, N,C int
RETURN:   0 or 1
PURPOSE:  test for (mathematical) equality of f/g and a partial fraction
          decomposition dec. The list dec has to have the same structure as the
          output of @ref{pfd}.
       @* The denominator g can also be given in factorized form as a list of
          an ideal of irreducible non constant polynomials and an intvec of
          exponents. This can save time since the first step in the algorithm is
          to factorize g. (a list of the zero-ideal and an empty intvec
          represents a denominator of 1.)
       @* By default the test is done (exactly) by bringing all terms of the
          decomposition on the same denominator and comparing to f/g.
       @* If additional parameters N [, C] are given and if @code{N>0}, a
          probabilistic method is chosen: evaluation at N random points with
          coordinates between -C and C. This may be faster for big polynomials.
SEE ALSO: pfd
EXAMPLE:  example checkpfd; shows an example"
{
  poly f = fraction[1];
  if(typeof(fraction[2])=="poly" || typeof(fraction[2])=="number" || typeof(fraction[2])=="int" || typeof(fraction[2])=="bigint")
    {if(fraction[2]==0) {ERROR("division by 0");}}
  def g = fraction[2];
  if(size(#)>0)
  {
    if(#[1]>0)
    {
      int N = #[1]; // number of random tests
      int max_val=16;
      if(size(#)>1) {max_val = #[2];}
      ideal values;
      ideal vars = maxideal(1);
      int d=nvars(basering);
      number val1,val2;
      int div_by_0;
      int i,j;
      for(i=1; i<=N; i++)
      {
        values = ideal(random(max_val,1,d));

        if(typeof(g)=="poly" || typeof(g)=="number" || typeof(g)=="int" || typeof(g)=="bigint")
          {val1 = number(substitute(poly(g),vars,values));}
        else{if(typeof(g)=="list") // denominator given in factorized form
        {
          val1 = number(1);
          for(j=1; j<=size(g[1]); j++)
            {val1 = val1 * number(substitute(g[1][j]^g[2][j],vars,values));}
        }
        else {ERROR("wrong type for second argument, expected poly or list");}}

        if(val1==0) {continue;}
        val1 = number(substitute(f,vars,values))/val1;
        val2, div_by_0 = evaluatepfd(dec,values,2);
        if(div_by_0) {continue;}
        if(val1 != val2)
          {return(0);}
      }
      return(1);
    }
  }
  if(typeof(dec)=="list")
  {
    ideal q = dec[1];
    list terms = dec[2];
  }
  else{if(typeof(dec)=="partfrac")
  {
    ideal q = dec.q;
    list terms = dec.terms;
  }
  else{if(typeof(dec)=="partfrac2")
  {
    ideal q = denominator_factors;
    list terms = dec.terms;
  }
  else
    {ERROR("wrong argument type, expected list or partfrac, got "+typeof(dec));}
  }}

  if(size(terms)==0) {return(f==0);}
  int m = size(q);
  if(m==0)
  {
    if(size(terms)!=1) {ERROR("invalid input");}
    if(size(terms[1][2])!=0) {ERROR("invalid input");}
    poly term = terms[1][1];

    poly denom=1;
    if(typeof(g)=="poly" || typeof(g)=="number" || typeof(g)=="int" || typeof(g)=="bigint")
      {denom=g;}
    else{if(typeof(g)=="list")    //denominator given in factorized form
      {for(i=1;i<=size(g[1]);i++) {denom = denom * g[1][i]^g[2][i];}}
    else {ERROR("wrong type for second argument, expected poly or list");}}

    if(deg(denom)>0)
    {
      if(reduce(f,denom)==0)
      {
        return(f div denom == term);
      }
      return(0);
    }
    return(f/denom == term);
  }

  int jmax,j,ind,k;
  intvec e_max=0:m;
  int imax = size(terms);
  for(int i=1; i<=imax; i++)
  {
    jmax = size(terms[i][2]);
    for(j=1; j<=jmax; j++)
    {
      ind = terms[i][2][j];
      e_max[ind] = max(e_max[ind],terms[i][3][j]);
    }
  }
  poly num;
  poly sum_of_numerators = 0;
  intvec e;
  for(i=1; i<=imax; i++)
  {
    e = e_max;
    jmax = size(terms[i][2]);
    for(j=1; j<=jmax; j++)
    {
      ind = terms[i][2][j];
      e[ind] = e[ind]-terms[i][3][j];
    }
    num = terms[i][1];
    for(j=1; j<=m; j++)
      {num = num * q[j]^(e[j]);}
    sum_of_numerators = sum_of_numerators + num;
  }
  // the decomposition is now equal to sum_of_numerators/product(q[i]^e_max[i]) (i from 1 to imax)
  // now: check if this equals f/g:
  if(typeof(g)=="poly" || typeof(g)=="number" || typeof(g)=="int" || typeof(g)=="bigint")
  {
    list fact = factorize(poly(g));
    ideal q_g = delete(fact[1],1);
    intvec e_g = delete(fact[2],1);
    num = f/fact[1][1];
  }
  else{if(typeof(g)=="list")    //denominator given in factorized form
  {
    ideal q_g = g[1];
    intvec e_g = g[2];
    num = f;
  }
  else {ERROR("wrong type for second argument, expected poly or list");}}

  int m_g = size(q_g);
  int expon;
  number c;
  for(i=1; i<=m_g; i++)
  {
    j=0;
    for(k=1; k<=m; k++)
    {
      c = leadcoef(q[k])/leadcoef(q_g[i]);
      if(c*q_g[i]==q[k]) {j=k; break;}
    }
    if(j==0)
      {sum_of_numerators = sum_of_numerators*q_g[i]^e_g[i];}
    else
    {
      num = num*(c^e_g[i]);    //fix lead coefficient
      expon = e_g[i]-e_max[j];
      if(expon>0)
        {sum_of_numerators = sum_of_numerators*q[j]^expon;}
      else{if(expon<0)
        {num = num*q[j]^(-expon);}}
    }
  }
  return(sum_of_numerators==num);
}
example
{
  "EXAMPLE:";
  echo=voice;
  ring R = 0,(x,y),dp;
  poly f = x^3+3*x^2*y+2*y^2-x^2+4*x*y;
  poly g = x^2*y*(x-1)*(x-y)^2;

  // partial fraction decomposition of f/g:
  list dec = pfd(f,g);
  // some other decomposition (not equal to f/g):
  list wrong_dec = pfd(f+1,g);

  displaypfd_long(dec);
  list fraction = f,g;

  // exact test:
  checkpfd(fraction,dec);
  checkpfd(fraction,wrong_dec);
  // probabilistic test (evaluation at 10 random points):
  checkpfd(fraction,dec,10);
  checkpfd(fraction,wrong_dec,10);
}

proc evaluatepfd(def dec, ideal values, list #)
"USAGE:   evaluatepfd(dec, values[, mode]);   dec list, values ideal, mode int
RETURN:   the number gotten by substituting the numbers generating the ideal
          @code{values} for the variables in the partial fraction decomposition
          @code{dec}. The list @code{dec} has to have the same structure as the
          output of @ref{pfd}.
       @* @code{mode=1}: raise Error in case of division by 0 (default)
       @* @code{mode=2}: return a second integer which is 1 if the denominator
          becomes 0, and 0 otherwise.
SEE ALSO: pfd
EXAMPLE:  example evaluatepfd; shows an example"
{
  if(typeof(dec)=="list")
  {
    ideal q = dec[1];
    list terms = dec[2];
  }
  else{if(typeof(dec)=="partfrac")
  {
    ideal q = dec.q;
    list terms = dec.terms;
  }
  else{if(typeof(dec)=="partfrac2")
  {
    ideal q = denominator_factors;
    list terms = dec.terms;
  }
  else
    {ERROR("wrong argument type, expected list or partfrac, got "+typeof(dec));}
  }}
  if(size(terms)==0) {return(number(0));}

  int mode = 1;
  if(size(#)>0) {mode = #[1];}

  ideal vars = maxideal(1); // ideal generated by ring variables
  number val=0;
  number denom;
  int i,j,m;
  for(i=1; i<=size(terms); i++)
  {
    //v, j = evaluatepfd_single_term(terms[i], q, vars, values, mode)
    denom = 1;
    m = size(terms[i][2]);
    for(j=1; j<=m; j++)
    {
      denom = denom * (number(substitute(q[terms[i][2][j]],vars,values)))^terms[i][3][j];
      if(denom == 0)
      {
        if(mode==1) {ERROR("division by 0");}
        else {return(0,1);};
      }
    }
    val = val + number(substitute(terms[i][1],vars,values))/denom;
  }
  if(mode==1) {return(val);}
  else {return(val,0);}
}
example
{
  "EXAMPLE:";
  echo=voice;
  ring R = 0,(x,y),dp;
  poly f = x+2*y;
  poly g = x^2-y^2;

  // partial fraction decomposition of f/g:
  list dec = pfd(f,g);

  displaypfd_long(dec);
  // evaluation at x=2, y=1:
  ideal values = 2,1;
  evaluatepfd(dec,values);

  // compare: f(2,1)/g(2,1) = (2+2*1)/(2^2-1^1) = 4/3
}

static proc evaluatepfd_single_term(list term, ideal q, ideal vars, ideal values)
{
  number denom = 1;
  int m = size(term[2]);
  for(int j=1; j<=m; j++)
  {
    denom = denom * (number(substitute(q[term[2][j]],vars,values)))^term[3][j];
    if(denom == 0) {return(0,1);}
  }
  return(number(substitute(term[1],vars,values))/denom);
}

static proc equality_for_lists(def a, def b)
{
  if(typeof(a)=="list")
  {
    if(typeof(b)=="list")
    {
      int n=size(a);
      if(n!=size(b)) {return(0);}
      for(int i=1;i<=n;i++)
      {
        if(not(equality_for_lists(a[i],b[i]))) {return(0);}
      }
      return(1);
    }
    else {return(0);}
  }
  else
  {
    if(typeof(b)=="list") {return(0);}
    else {return(a==b);}
  }
}

proc find_entry(def l, def entry)
{
  int n=size(l);
  for(int i=1; i<=n; i++)
    {if(equality_for_lists(entry,l[i])) {return(i);}}
  return(0);
}

proc displaypfd(def dec)
"USAGE:   displaypfd(dec);   dec list
PURPOSE:  print a partial fraction decomposition @code{dec} in a readable way.
          The list @code{dec} has to have the same structure as the output of
          @ref{pfd}.
SEE ALSO: pfd, displaypfd_long, getStringpfd, getStringpfd_indexed
EXAMPLE:  example displaypfd; shows an example"
{
  if(typeof(dec)=="list")
  {
    ideal q = dec[1];
    list terms = dec[2];
  }
  else{if(typeof(dec)=="partfrac")
  {
    ideal q = dec.q;
    list terms = dec.terms;
  }
  else{if(typeof(dec)=="partfrac2")
  {
    ideal q = denominator_factors;
    list terms = dec.terms;
  }
  else
    {ERROR("wrong argument type, expected list or partfrac, got "+typeof(dec));}
  }}
  int nterms=size(terms);
  if(nterms==0) {print("0"); return();}
  if(nterms==1 && size(terms[1][2])==0) {print(terms[1][1]); return();}
  int jmax,j;
  string s1,s2;
  for(int i=1; i<=nterms; i++)
  {
    s1 = "(" + string(terms[i][1]);
    if(i>1) {s1 = "+ " + s1;}
    else {s1 = "  " + s1;}
    if(size(terms[i][2])>0)
    {
      s2 = ") / (";
      jmax = size(terms[i][2]);
      for(j=1; j<=jmax; j++)
      {
        s2 = s2 + "q" + string(terms[i][2][j]);
        if(terms[i][3][j] != 1) {s2 = s2 + "^" + string(terms[i][3][j]);}
        if(j<jmax) {s2 = s2 + "*";}
      }
      s2 = s2 + ")";
    }
    else {s2 = ")";}

    if(size(s1)+size(s2)>192) {s1=s1[1..(192-size(s2))]; s1 = s1 + "... ";}
    print(s1+s2);
  }
  if(size(q)>0) {print("where");}
  for(i=1; i<=size(q); i++)
  {
    printf("q%s = %s",i,q[i]);
  }
  if(size(terms)==1) {printf("(%s term)", 1);}
  else {printf("(%s terms)", size(terms));}
}
example
{
  "EXAMPLE:";
  echo=voice;
  ring R = 0,(x,y),dp;
  poly f = x^3+3*x^2*y+2*y^2-x^2+4*x*y;
  poly g = x^2*y*(x-1)*(x-y)^2;

  list dec = pfd(f,g);

  displaypfd(dec);
}

proc displaypfd_long(def dec)
"USAGE:   displaypfd_long(dec);   dec list
PURPOSE:  like @ref{displaypfd}, but denominators are written out, not indexed.
SEE ALSO: pfd, displaypfd, getStringpfd, getStringpfd_indexed
EXAMPLE:  example displaypfd_long; shows an example"
{
  if(typeof(dec)=="list")
  {
    ideal q = dec[1];
    list terms = dec[2];
  }
  else{if(typeof(dec)=="partfrac")
  {
    ideal q = dec.q;
    list terms = dec.terms;
  }
  else{if(typeof(dec)=="partfrac2")
  {
    ideal q = denominator_factors;
    list terms = dec.terms;
  }
  else
    {ERROR("wrong argument type, expected list or partfrac, got "+typeof(dec));}
  }}
  int nterms = size(terms);
  if(nterms==0) {print("0"); return();}
  if(nterms==1 && size(terms[1][2])==0) {print(terms[1][1]); return();}
  print("  "+getStringFraction(terms[1],q));
  for(int i=2; i<=nterms; i++)
    {print("+ "+getStringFraction(terms[i],q));}
  if(size(terms)==1) {printf("(%s term)", 1);}
  else {printf("(%s terms)", size(terms));}
}
example
{
  "EXAMPLE:";
  echo=voice;
  ring R = 0,(x,y),dp;
  poly f = x^3+3*x^2*y+2*y^2-x^2+4*x*y;
  poly g = x^2*y*(x-1)*(x-y)^2;

  list dec = pfd(f,g);

  displaypfd_long(dec);
}

proc getStringpfd(def dec)
"USAGE:   getStringpfd(dec);   dec list
PURPOSE:  turn a partial fraction decomposition @code{dec} into one string. The
          list @code{dec} has to have the same structure as the output of
          @ref{pfd}.
SEE ALSO: pfd, getStringpfd_indexed, displaypfd, displaypfd_long
EXAMPLE:  example getStringpfd; shows an example"
{
  if(typeof(dec)=="list")
  {
    ideal q = dec[1];
    list terms = dec[2];
  }
  else{if(typeof(dec)=="partfrac")
  {
    ideal q = dec.q;
    list terms = dec.terms;
  }
  else{if(typeof(dec)=="partfrac2")
  {
    ideal q = denominator_factors;
    list terms = dec.terms;
  }
  else
    {ERROR("wrong argument type, expected list or partfrac, got "+typeof(dec));}
  }}
  int nterms = size(terms);
  if(nterms==0) {return("0");}
  string s = getStringFraction(terms[1],q);
  for(int i=2; i<=nterms; i++)
    {s = s+" + "+getStringFraction(terms[i],q);}
  return(s);
}
example
{
  "EXAMPLE:";
  echo=voice;
  ring R = 0,(x,y),dp;
  poly f = x^3+3*x^2*y+2*y^2-x^2+4*x*y;
  poly g = x^2*y*(x-1)*(x-y)^2;

  list dec = pfd(f,g);

  displaypfd_long(dec);
  getStringpfd(dec);
}

proc getStringpfd_indexed(def dec)
"USAGE:   getStringpfd_indexed(dec);   dec list
PURPOSE:  turn a partial fraction decomposition @code{dec} into one string,
          writing the denominator factors just as @code{q1},@code{q2},... . The
          list @code{dec} has to have the same structure as the output of
          @ref{pfd}.
SEE ALSO: pfd, getStringpfd, displaypfd, displaypfd_long
EXAMPLE:  example getStringpfd_indexed; shows an example"
{
  if(typeof(dec)=="list")
  {
    if(typeof(dec[1])=="ideal") {list terms = dec[2];}
    else {list terms = dec;}
  }
  else{if(typeof(dec)=="partfrac")
  {
    list terms = dec.terms;
  }
  else{if(typeof(dec)=="partfrac2")
  {
    ideal q = denominator_factors;
    list terms = dec.terms;
  }
  else
    {ERROR("wrong argument type, expected list or partfrac, got "+typeof(dec));}
  }}
  int nterms = size(terms);
  if(nterms==0) {return("0");}
  string s = getStringFraction_indexed(terms[1]);
  for(int i=2; i<=nterms; i++)
    {s = s+" + "+getStringFraction_indexed(terms[i]);}
  return(s);
}
example
{
  "EXAMPLE:";
  echo=voice;
  ring R = 0,(x,y),dp;
  poly f = x^3+3*x^2*y+2*y^2-x^2+4*x*y;
  poly g = x^2*y*(x-1)*(x-y)^2;

  list dec = pfd(f,g);

  displaypfd(dec);
  getStringpfd_indexed(dec);
}

static proc getStringFraction(list fraction, ideal q)
{
  int jmax,j;
  string s = "(" + string(fraction[1]);
  if(size(fraction[2])>0)
  {
    s = s + ")/(";
    jmax = size(fraction[2]);
    for(j=1; j<=jmax; j++)
    {
      s = s + "(" + string(q[fraction[2][j]]) + ")";
      if(fraction[3][j] != 1) {s = s + "^" + string(fraction[3][j]);}
      if(j<jmax) {s = s + "*";}
    }
  }
  s = s + ")";
  return(s);
}

static proc getStringFraction_indexed(list fraction)
{
  int jmax,j;
  string s = "(" + string(fraction[1]);
  if(size(fraction[2])>0)
  {
    s = s + ")/(";
    jmax = size(fraction[2]);
    for(j=1; j<=jmax; j++)
    {
      s = s + "q" + string(fraction[2][j]);
      if(fraction[3][j] != 1) {s = s + "^" + string(fraction[3][j]);}
      if(j<jmax) {s = s + "*";}
    }
  }
  s = s + ")";
  return(s);
}

proc string_to_poly(string s__)
{
      /*
  while (s__[size(s__)] == newline) {
    s__ = s__[1, size(s__) - 1];
    print("hacking newline off");
  }
      */
  poly p__;
  execute("p__="+s__+";");
  return(p__);
}

proc readInputTXT(def file__, list #)
"USAGE:   readInputTXT(file[, mode]), file string, mode int
          readInputTXT(filelist[, mode]), filelist list, mode int
PURPOSE:  read matrix of rational functions from a txt-file and turn it into a
          matrix (i.e. a list of lists) of pairs of polynomials (numerators and
          denominators). The string @code{file} should be the [directory +] name
          of the file in the form \"@code{<path-to-file>/<filename>.txt}\".
       @* The input file should be a list of lists separated by the characters
          \"{\", \"}\" and \",\". Example:
       @* \"{{(x+y)/(x^2-x*y), -(x^2*y+1)/(y), x^2}, {(x+1)/y, y/x, 0}}\"
       @* Each rational function has to be an expression of the form \"a\",
          \"(a)/(b)\", \"(b)^(-n)\" or \"(a)*(b)^(-n)\" where \"a\",\"b\" stand
          for polynomials (i.e. strings, that can be parsed as a polynomial with
          the @code{execute} command) and \"n\" stands for a positive integer. A
          minus sign \"-\" followed by such an expression is also allowed.
       @* IMPORTANT: The strings \"a\",\"b\" must NOT contain the symbol \"/\".
          (So in case the coefficient field is the rationals, all denominators
          in the coefficients of numerator and denominator polynomials should be
          cleared.)
       @* The file should contain less than 2^31 characters (filesize < 2 GB).
          For bigger files the matrix should be split row-wise into multiple
          matrices and saved in different files (each smaller than 2 GB). A list
          of the filenames (in the right order) can then be given as first
          argument instead.
       @* Also the basering has to match the variable names used in the
          input file(s).
       @* @code{mode=1} (default): save result to an ssi-file of the same name
       @* @code{mode=2}: return result
       @* @code{mode=3}: save to ssi-file AND return result
SEE ALSO: pfdMat
"
{
  system("--ticks-per-sec",1000);
  short = 0;
  if(!defined(basering))
    {ERROR("no basering defined!");}
  int left__,right__,pos1__,mid__,pos2__,tmp__,i__,j__,k__,t__,tt__,depth__;
  int mode__=1;
  if(size(#)>0) {mode__=#[1];}
  if(typeof(file__)=="list") // list of filenames given --> apply function to each
  {                          // file and concatenate the resulting matrices
    int n = size(file__);
    list mat__ = list();
    for(i__=1;i__<=n;i__++)
    {
      dbprint(sprintf("  file %s of %s:",i__,n));
      if(find(file__[i__],".txt")==0) {ERROR("wrong file type, expected txt");}
      printlevel = printlevel+1;
      mat__ = mat__ + readInputTXT(file__[i__],2);
      printlevel = printlevel-1;
    }

    if(mode__==2) {return(mat__);}

    string filename__ = file__[1][1,find(file__[1],".txt")-1];
    dbprint("  saving to file "+filename__+".ssi "); t__ = rtimer;
    write("ssi:w "+filename__+".ssi", mat__);
    dbprint(sprintf("  done! (%s ms)", rtimer-t__));

    if(mode__==3) {return(mat__);}
  }
  if(typeof(file__)!="string")
    {ERROR("wrong type for first argument (expected string or list)");}
  if(find(file__,".txt")==0) {ERROR("wrong file type, expected txt");}

  dbprint("  reading file "); t__=rtimer;
  string data__ = read(":r "+file__);
  dbprint(sprintf("  done! (%s ms)", rtimer-t__));

  dbprint("  processing input "); t__ = rtimer;
  left__ = find(data__,"{");
  right__ = find(data__,"}");
  tmp__ = find(data__,"{",left__+1);
  if(left__<tmp__ && tmp__<right__) {left__ = tmp__;}

  int finished__,n__;
  poly p__,q__;
  list row__,mat__;
  string s__,ss__;
  i__=0;
  while(1)
  {
    i__++;
    tt__ = rtimer;
    row__ = list();
    pos2__ = left__;
    finished__ = 0;
    j__=0;
    while(not finished__)
    {
      j__++;
      s__ = "";

      pos1__ = pos2__+1;
      pos2__ = find(data__,",",pos1__);
      if(pos2__==0 || pos2__>right__)    // end of row
      {
        finished__ = 1;
        pos2__ = right__;
      }
      s__ = data__[pos1__,pos2__-pos1__];
      mid__ = find(s__,"/");
      if(mid__==0)
      {
        tmp__ = find(s__,"^(-");
        if(tmp__==0)    //no denominator
        {
          execute("p__=" + s__);
          q__=1;
          row__[j__] = list(p__,q__);
          continue;
        }
        else    // denominator is given by a negative exponent
        {
          if(find(s__,"^(-",tmp__+1)>0)
            {ERROR(sprintf("invalid syntax in (%s,%s)-th entry:"
                              +" more than one negative exponent",i__,j__));}
          for(k__=tmp__+3; s__[k__]!=")"; k__++) {}
          execute("n__=" + s__[tmp__+3,k__-tmp__-3]);
          while(k__<size(s__))
          {
            k__++;
            if(s__[k__]!=" ")
            {ERROR(sprintf("invalid syntax in (%s,%s)-th entry",i__,j__));}
          }
          s__ = s__[1,tmp__-1];
          depth__=0;
          for(k__=tmp__-1; 1; k__--)
          {
            ss__ = s__[k__];
            if(ss__ == ")") {depth__++;}
            else{if(ss__ == "(") {depth__--;}}
            if(depth__==0) {break;}
          }
          if(k__>1)
          {
            while(1)
            {
              if(k__==0)
                {ERROR(sprintf("invalid syntax in (%s,%s)-th entry",i__,j__));}
              k__--;
              ss__ = s__[k__];
              if(ss__=="*" || ss__==" " || ss__=="-") {break;}
            }
          }
          s__ = s__[1,k__] + "1/" + s__[k__+1,size(s__)-k__] + "^" + string(n__);
          mid__ = k__+2;    // position of the character "/"
        }
      }
      if(find(s__,"/",mid__+1)>0)
        {ERROR(sprintf("invalid syntax in (%s,%s)-th entry:%n"
        +"no '/' allowed in the string representing the polynomials",i__,j__,0));}

      execute("p__=" + fixBrackets(s__[1,mid__-1]));
      execute("q__=" + fixBrackets(s__[mid__+1,size(s__)-mid__]));

      row__[j__] = list(p__,q__);
    }
    mat__[i__] = row__;    // append row to matrix
    dbprint(sprintf("    row %s done! (%s ms)",i__,rtimer-tt__));

    left__ = find(data__,"{",right__);
    if(left__==0) {break;}
    right__ = find(data__,"}",left__);
  }
  dbprint(sprintf("  done! (%s ms)", rtimer-t__));

  if(mode__==2) {return(mat__);}

  string filename__ = file__[1,find(file__,".txt")-1];
  dbprint("  saving to file "+filename__+".ssi "); t__ = rtimer;
  write("ssi:w "+filename__+".ssi", mat__);
  dbprint(sprintf("  done! (%s ms)", rtimer-t__));

  if(mode__==3) {return(mat__);}
}

static proc fixBrackets(string data)
{
  int pos=0;
  int left_brackets =0;
  int right_brackets=0;
  int n=size(data);
  while(pos<n)
  {
    pos = find(data,"(",pos+1);
    if(pos==0) {break;}
    left_brackets++;
  }
  pos=0;
  while(pos<n)
  {
    pos = find(data,")",pos+1);
    if(pos==0) {break;}
    right_brackets++;
  }
  int difference = left_brackets-right_brackets;
  if(difference>0)
  {
    for(int i=1; i<=difference; i++) {data = data+")";}
  }
  if(difference<0)
  {
    for(int i=1; i<=-difference; i++) {data = "("+data;}
  }
  return(data);
}

static proc pfdWrap(poly f, def g, int i, int j, link logfile, int output_mode)
{
  system("--ticks-per-sec",1000);
  if(output_mode>3)
    {write("ssi:w pfd_results_"+string(i)+"_"+string(j)
           +".ssi","task started, but not finished yet");}
  int t0 = rtimer;
  list result = pfd(f,g);
  fprintf(logfile,"_[%s,%s]: %s ms",i,j,rtimer-t0);
  if(output_mode>3)
    {write("ssi:w pfd_results_"+string(i)+"_"+string(j)+".ssi",result);}
  return(result);
}

static proc testEntry(int i, int j, list fraction, list dec, link logfile, int N);
{
  int t=rtimer;
  system("--ticks-per-sec",1000);
  int result = checkpfd(fraction,dec,N);
  if(result==1) {fprintf(logfile, " _[%s,%s]: correct (%s ms)",i,j,rtimer-t);}
  else          {fprintf(logfile, " _[%s,%s]: WRONG! (%s ms)", i,j,rtimer-t);}
  return(result);
}

proc pfdMat(def infile, list #)
"USAGE:   pfdMat(file[, dotest, ignore_nonlin, output_mode, parallelize]);
          file string, dotest,ignore_nonlin,output_mode,parallelize int
PURPOSE:  apply @code{pfd} to all entries of a matrix of rational functions
          saved in a txt-file. The string @code{file} should be the
          [directory +] name of the file.
       @* The input file can either be a txt-file or an ssi-file created with
          @code{readInputTXT}. In case of a txt-file, the base ring has to match
          and the matrix has to be in the same format specified in
          @ref{readInputTXT}. Also, txt-files that are bigger than 2 GB should
          be split as described for @code{readInputTXT} and a list of the
          filenames can be given as first argument instead.
       @* The result is saved in multiple txt- (and ssi-) files (see below)
          within the directory of the input file.
       @* Also a logfile is created, which protocols the memory used and the
          runtimes of @code{pfd} for each matrix entry in real-time.

       @* There are also 4 optional arguments:
       @* If @code{dotest} is nonzero, test the results with checkpfd:
       @* @code{dotest<0} (default): exact test (may be slow),
       @* @code{dotest>0}: do this amount of probabilistic tests for each entry
                           (see @ref{checkpfd}).

       @* If @code{ignore_nonlin} is nonzero (default), for each denominator,
          the nonlinear factors in the factorization are removed before applying
          @code{pfd} (and added back in in the output files).

       @* If @code{parallelize} is nonzero (default), the decompositions are
          calculated in parallel using @ref{parallel_lib}.

       @* The parameter @code{output_mode} controls the output files created:
       @* @code{output_mode=1} (default): The result consists of two files:
          @code{<filename>_pfd_indexed.txt} contains the matrix of all
          decompositions (as list of lists separated by the characters \"{\",
          \"}\" and \",\") where all the denominators are written in factorized
          form depending on irreducible factors @code{q1}, @code{q2}, ... .
          The file @code{<filename>_denominator_factors.txt} lists all the
          polynomials @code{q1}, @code{q2}, ... .
       @* @code{output_mode=2}: Additionally to mode 1, the file
          @code{<filename>_pfd.txt} is created, which also contains the matrix
          of decompositions but the factors in the denominators are written out.
       @* @code{output_mode=3}: Additionally to mode 2, the result and some
          intermediate results are saved as SINGULAR objects in ssi-files:
       @* @code{<filename>.ssi}: contains the result of @code{readInputTXT} in
          case a txt-file was given as input.
       @* @code{<filename>_factorized_denominators.ssi}: like the first file,
          but the denominators are saved in factorized form, that is as a list
          of an ideal of irreducible non constant polynomials and an intvec of
          exponents.
       @* @code{<filename>_linear_part.ssi} (only if @code{ignore_nonlin} is
          nonzero): like the previous file, but all the irreducible denominator
          factors are removed
       @* @code{<filename>_non_linear_factors.ssi} (only if @code{ignore_nonlin}
          is nonzero): a list of an ideal @code{p} generated by irreducible
          polynomials and a matrix (list of lists) of the nonlinear denominator
          factors of each entry of the input matrix. These are represented as
          lists of an intvec of indices @code{i} for which @code{p[i]} occurs
          as a (nonlinear) factor in the denominator and an intvec containing
          the exponents of those factors.
       @* @code{<filename>_pfd.ssi}: a list, where the first entry is an ideal
          @code{q} of denominator factors and the second entry is a matrix (as
          list of lists) containing the decompositions, each of which is a list
          of terms, where a term is represented as in the result of @ref{pfd}
          by a list containing
       @* 1) the numerator polynomial
       @* 2) an intvec of indices @code{i} for which @code{q[i]} occurs
             as a factor in the denominator
       @* 3) an intvec containing the exponents of those irreducible factors.
       @* IMPORTANT: If @code{ignore_nonlin} is nonzero, this file contains the
          decompositions of the entries of the matrix in
          @code{<filename>_linear_part.ssi}. Thus the nonlinear factors, are
          NOT contained in this file.
       @* @code{output_mode=4}: Additionally to mode 3, the direct output of
          each call of @code{pfd} is saved in separate ssi-files called
          @code{pfd_results_i_j.ssi} where i,j are the matrix indices. This
          creates a lot of files, but may be useful in case the algorithm does
          not terminate in time for every matrix entry. Other than the files
          created in mode 1-3, these files are saved in the current directory,
          rather than the directory of the input file.
SEE ALSO: readInputTXT, pfd, checkpfd, checkpfdMat
"
{
  system("--ticks-per-sec",1000);
  short = 0;
  int dotest,ignore_nonlin,output_mode,parallelize = -1,1,1,1;
  if(size(#)>0) {dotest = #[1];}
  if(size(#)>1) {ignore_nonlin = #[2];}
  if(size(#)>2) {output_mode = #[3];}
  if(size(#)>3) {parallelize = #[4];}

  int i,j,k,l,ind;
  list arguments,results;

  dbprint(newline+"reading data "); int t0=rtimer;

  if(typeof(infile)=="list")
  {
    printlevel = printlevel+1;
    if(output_mode>2) {list mat = readInputTXT(infile,3);}
    else {list mat = readInputTXT(infile,2);}
    printlevel = printlevel-1;
    int pos=find(infile[1],".txt");
    string filename = infile[1][1,pos-1];
  }
  else
  {
    int pos=find(infile,".txt");
    if(pos!=0)
    {
      printlevel = printlevel+1;
      if(output_mode>2) {list mat = readInputTXT(infile,3);}
      else {list mat = readInputTXT(infile,2);}
      printlevel = printlevel-1;
    }
    else
    {
      pos=find(infile,".ssi");
      if(pos!=0) {list mat = read("ssi:r "+infile);}
      else {ERROR("invalid file type, expected ssi or txt");}
    }
    string filename = infile[1,pos-1];
  }

  link qfile = ":w "+filename+"_denominator_factors.txt";
  int n = size(mat);
  int m = size(mat[1]);
  dbprint(sprintf("done! (%s ms)",rtimer-t0));

  if(typeof(mat[1][1][2])!="list")    // denominators are not yet factorized
  {
    dbprint("factorizing the denominators "); t0=rtimer;
    printlevel = printlevel+1;
    mat = FactDenom(mat);
    printlevel = printlevel-1;
    if(output_mode>2)
      {write("ssi:w "+filename+"_factorized_denominators.ssi",mat);}
    dbprint(sprintf("done! (%s ms)",rtimer-t0));
  }

  if(ignore_nonlin)
  {
    dbprint("removing nonlinear denominator factors before pfd is applied");
    list nonlin_denom_factors;
    ideal p;
    printlevel = printlevel+1;
    mat, nonlin_denom_factors, p = removeNonlinearFactors(mat, filename);
    printlevel = printlevel-1;
    if(output_mode>2)
    {
      dbprint("saving nonlinear factors to "+filename+"_non_linear_factors.ssi ");
      t0 = rtimer;
      write("ssi:w "+filename+"_non_linear_factors.ssi", list(p,nonlin_denom_factors));
      dbprint(sprintf("done! (%s ms)",rtimer-t0));
      dbprint("saving input matrix without the nonlinear factors to "
              +filename+"_linear_part.ssi ");
      t0 = rtimer;
      write("ssi:w "+filename+"_linear_part.ssi", mat);
      dbprint(sprintf("done! (%s ms)",rtimer-t0));
    }
  }

  if(parallelize)
  {
    dbprint("creating tasks "); t0=rtimer;
    write(":w "+filename+"_pfdMat_logfile.txt","finished matrix entries with runtimes "
          +"(calculated in parallel on "+string(getcores())+" cores):");
    link logfile = ":a "+filename+"_pfdMat_logfile.txt";
    for(i=1; i<=n; i++)
    {
      for(j=1; j<=m; j++)
      {
        ind = m*(i-1)+j;
        arguments[ind] = list(mat[i][j][1],mat[i][j][2],i,j,logfile,output_mode);
      }
    }
    dbprint(sprintf("done! (%s ms)",rtimer-t0));

    dbprint("applying pfd to each matrix entry "); t0 = rtimer;
    results = parallelWaitAll("pfdWrap",arguments);
    arguments = list();
    dbprint(sprintf("done! (%s ms)",rtimer-t0));

    write(logfile,"decomposition: "+string(rtimer-t0)+" ms and "+string(memory(2))
                   +" Byte Memory max. (after calling pfd on each matrix entry)");

    dbprint("writing results in matrix shape "); t0 = rtimer;
    list dec_mat;
    for(i=1; i<=n; i++)
    {
      dec_mat[i] = list();
      for(j=1; j<=m; j++)
      {
        ind = m*(i-1)+j;
        dec_mat[i][j] = results[ind];
      }
    }
    results = list();
    dbprint(sprintf("done! (%s ms)",rtimer-t0));
  }
  else
  {
    dbprint("applying pfd to each matrix entry "); t0=rtimer;
    write(":w "+filename+"_pfdMat_logfile.txt",
          "finished matrix entries with runtimes (no parallelization):");
    link logfile = ":a "+filename+"_pfdMat_logfile.txt";
    list dec_mat;
    for(i=1; i<=n; i++)
    {
      dec_mat[i] = list();
      for(j=1; j<=m; j++)
      {
        dec_mat[i][j] = pfdWrap(mat[i][j][1],mat[i][j][2],i,j,logfile,output_mode);
      }
    }
    dbprint(sprintf("done! (%s ms)",rtimer-t0));
    write(logfile,"decomposition: "+string(rtimer-t0)+" ms and "+string(memory(2))
          +" Byte Memory max. (after calling pfd on each matrix entry)");
 }

  dbprint("making one single list of denominator factors "); t0 = rtimer;
  ideal q,new_q;
  intvec dict;
  for(i=1; i<=n; i++)
  {
    for(j=1; j<=m; j++)
    {
      new_q = dec_mat[i][j][1];
      dec_mat[i][j] = dec_mat[i][j][2];
      dict = 0:0;
      for(k=1; k<=size(new_q); k++)
      {
        ind = find_entry(q,new_q[k]);
        if(ind==0)
        {
          ind = size(q)+1;
          q[ind] = new_q[k];
        }
        dict[k] = ind;
      }
      for(k=1; k<=size(dec_mat[i][j]); k++)
      {
        if(size(dec_mat[i][j][k][2])>0)
          {dec_mat[i][j][k][2] = intvec(dict[dec_mat[i][j][k][2]]);}
      }
    }
    dbprint(sprintf("  row %s complete!",i));
  }
  dbprint(sprintf("done! (%s ms)",rtimer-t0));

  if(output_mode>2)
  {
    dbprint("saving result to "+filename+"_pfd.ssi "); t0 = rtimer;
    write("ssi:w "+filename+"_pfd.ssi", list(q,dec_mat));
    dbprint(sprintf("done! (%s ms)",rtimer-t0));
  }

  if(ignore_nonlin)
  {
    ind = size(q);
    for(i=1; i<=size(p); i++) {q[ind+i]=p[i];} // add nonlin. polynomials to q
    for(i=1; i<=n; i++)
    {
      for(j=1; j<=m; j++)
      {
        nonlin_denom_factors[i][j][1] = nonlin_denom_factors[i][j][1]+ind; // adjust indices
      }
    }
  }

  if(ignore_nonlin)
    {dbprint(sprintf("creating readable .txt-files (including the nonlinear factors again)"));}
  else
    {dbprint(sprintf("creating readable .txt-files "));}
  t0 = rtimer;
  dbprint(" indexed ("+filename+"_pfd_indexed.txt):");
  printlevel = printlevel+1;
  if(ignore_nonlin)
    {saveResultTXT_indexed(dec_mat, filename+"_pfd_indexed", nonlin_denom_factors);}
  else {saveResultTXT_indexed(dec_mat, filename+"_pfd_indexed");}
  printlevel = printlevel-1;
  for(i=1; i<=size(q); i++) {fprintf(qfile, "q%s = %s;", i, q[i]);}
  if(output_mode>1)
  {
    dbprint(" denominators written out ("+filename+"_pfd.txt):");
    printlevel = printlevel+1;
    if(ignore_nonlin)
      {saveResultTXT(dec_mat, q, filename+"_pfd", nonlin_denom_factors);}
    else {saveResultTXT(dec_mat, q, filename+"_pfd");}
    printlevel = printlevel-1;
  }
  dbprint(sprintf("done! (%s ms)",rtimer-t0));

  if(dotest)
  {
    if(dotest<0)
      {dbprint("checking for correctness (exact test) ");}
    else
      {dbprint(sprintf("checking for correctness (%s random evaluations per entry) ",dotest));}
    t0 = rtimer;
    if(parallelize)
    {
      for(i=1; i<=n; i++)
      {
        for(j=1; j<=m; j++)
        {
          arguments[m*(i-1)+j]=list(i,j,mat[i][j],list(q,dec_mat[i][j]),logfile,dotest);
        }
      }
      results = parallelWaitAll("testEntry",arguments);
    }
    else
    {
      for(i=1; i<=n; i++)
      {
        for(j=1; j<=m; j++)
        {
          results[m*(i-1)+j]=testEntry(i,j,mat[i][j],list(q,dec_mat[i][j]),logfile,dotest);
        }
      }
    }
    dbprint(sprintf("%s out of %s = %sx%s decompositions are correct! (%s ms)%n",
            sum(results),n*m,n,m,rtimer-t0,0));
    write(logfile,"checking for correctness: "+string(rtimer-t0)+" ms and "
          +string(memory(2))+" Byte Memory max. (at the end of pfdMat), "
          +string(sum(results))+" correct out of "+string(n*m));
  }
}

static proc FactDenom(list mat)
{
  system("--ticks-per-sec",1000);
  int i,j,k,ind,t,counter;
  int n = size(mat);
  int m = size(mat[1]);
  list denom = list();
  for(i=1; i<=n; i++)
  {
    denom[i] = list();
    for(j=1; j<=m; j++)
    {
      denom[i][j] = mat[i][j][2];
      mat[i][j][2] = list(ideal(),intvec(0:0));
    }
  }
  int expon;
  list fact;
  number lcoeff;
  int timeout = 60000;
  int finished = 0;
  list arguments,results;
  ideal q;
  while(!finished)
  {
    t = rtimer;
    for(i=1; i<=n; i++)   // create argument list
    {
      for(j=1; j<=m; j++)
        {arguments[m*(i-1)+j] = list(denom[i][j]);}
    }

    results = parallelWaitAll("factorize",arguments,timeout);
    arguments = list();

    for(i=1; i<=n; i++)   // update q, mat, denom
    {
      for(j=1; j<=m; j++)
      {
        ind = m*(i-1)+j;
        if(typeof(results[ind]) != "none")
        {
          fact = results[ind];
          for(k=2; k<=size(fact[1]); k++)
          {
            lcoeff = leadcoef(fact[1][k]);
            fact[1][k] = fact[1][k]/lcoeff;
            fact[1][1] = fact[1][1]*(lcoeff^fact[2][k]); // polynomial is monic (thus unique)
            lcoeff = content(fact[1][k]);
            fact[1][k] = fact[1][k]/lcoeff;
            fact[1][1] = fact[1][1]*(lcoeff^fact[2][k]); // polynomial has nice coefficients

            // add a new factor to q:
            ind = find_entry(q,fact[1][k]);
            if(ind==0) {q[size(q)+1] = fact[1][k];}
            // complete the factorization of the i,j-th denominator:
            ind = find_entry(mat[i][j][2][1],fact[1][k]);
            if(ind==0)
            {
              ind = size(mat[i][j][2][1])+1;
              mat[i][j][2][1][ind] = fact[1][k];
              mat[i][j][2][2][ind] = fact[2][k];
            }
            else
            {
              mat[i][j][2][2][ind] = mat[i][j][2][2][ind] + fact[2][k];
            }
          }
          mat[i][j][1] = mat[i][j][1]/fact[1][1];
          denom[i][j] = 1;
        }
      }
    }
    results = list();

    finished = 1;
    counter = n*m;
    for(i=1; i<=n; i++) // factorize by any known factors (from q)
    {
      for(j=1; j<=m; j++)
      {
        for(k=1; k<=size(q); k++)
        {
          expon=0;
          while(reduce(denom[i][j],q[k])==0)
          {
            denom[i][j] = denom[i][j]/q[k];
            expon++;
          }
          if(expon>0)
          {
            ind = size(mat[i][j][2][1])+1;
            mat[i][j][2][1][ind] = q[k];
            mat[i][j][2][2][ind] = expon;
          }
        }
        if(deg(denom[i][j])==0)
        {
          mat[i][j][1] = mat[i][j][1]/denom[i][j];
          denom[i][j] = poly(1);
        }
        if(denom[i][j]!=poly(1)) {finished = 0; counter--;}
      }
    }
    timeout = timeout*2;
    dbprint(sprintf("  %s out of %s denominators factorized completely (%s ms)",
                                                         counter,n*m,rtimer-t));
  }
  return(mat);
}

static proc saveResultTXT_indexed(list dec, string filename, list #)
{
  // expect dec = list(list(dec11, dec12, ...), list(dec21, dec22, ...), ...),
  // where dec11, dec12, ... are decompositions of form list(list(poly, intvec, intvec), ...)
  system("--ticks-per-sec",1000);
  list nonlinFactors = list();
  if(size(#)>0) {nonlinFactors = #;}
  link file = ":w "+filename+".txt";

  int i,j;
  int t;
  string s="{";
  int n=size(dec);
  int m=size(dec[1]);
  int k;
  for(i=1; i<=n; i++)
  {
    t = rtimer;
    s = s+"{";
    for(j=1; j<=m; j++)
    {
      if(size(nonlinFactors)>0)
      {
        if(size(nonlinFactors[i][j][1])>0)
        {
          s = s + getStringFraction_indexed(list(poly(1))+nonlinFactors[i][j])
                + " * (" + getStringpfd_indexed(dec[i][j]) + "), ";
          j++; continue;
        }
      }
      s = s + getStringpfd_indexed(dec[i][j]) + ", ";
    }
    k = size(s);
    s[k-1] = "}"; s[k] = ","; s = s+" ";
    dbprint(sprintf("  row %s done! (%s ms)",i,rtimer-t));
  }
  k = size(s);
  s[k-1] = "}"; s[k] = " ";
  write(file,s);
}

static proc saveResultTXT(list dec, ideal q, string filename, list #)
{
  // expect dec = list(list(dec11, dec12, ...), list(dec21, dec22, ...), ...),
  // where dec11, dec12, ... are decompositions of form list(list(poly, intvec, intvec), ...)
  system("--ticks-per-sec",1000);
  list nonlinFactors = list();
  if(size(#)>0) {nonlinFactors = #;}
  link file = ":w "+filename+".txt";

  int i,j;
  int t;
  string s="{";
  int n=size(dec);
  int m=size(dec[1]);
  int k;
  for(i=1; i<=n; i++)
  {
    t = rtimer;
    s = s+"{";
    for(j=1; j<=m; j++)
    {
      if(size(nonlinFactors)>0)
      {
        if(size(nonlinFactors[i][j][1])>0)
        {
          s = s + getStringFraction(list(poly(1))+nonlinFactors[i][j],q)
                + " * (" + getStringpfd(list(q,dec[i][j])) + "), ";
          j++; continue;
        }
      }
      s = s + getStringpfd(list(q,dec[i][j])) + ", ";
    }
    k = size(s);
    s[k-1] = "}"; s[k] = ","; s = s+" ";
    dbprint(sprintf("  row %s done! (%s ms)",i,rtimer-t));
  }
  k = size(s);
  s[k-1] = "}"; s[k] = " ";
  write(file,s);
}

static proc removeNonlinearFactors(list fractions, string filename)
{
  int n=size(fractions);
  int m=size(fractions[1]);
  int i,j,k,t0,ind;
  ideal p;
  list nonlin_denom_factors;
  intvec factors,exponents;
  list fac;
  for(i=1; i<=n; i++)
  {
    t0 = rtimer;
    nonlin_denom_factors[i] = list();
    for(j=1; j<=m; j++)
    {
      fac = fractions[i][j][2];
      factors = 0:0;
      exponents = 0:0;
      for(k=1; k<=size(fac[1]); k++)
      {
        if(deg(poly(fac[1][k]))>1)
        {
          // add the nonlin. factor fac[1][k] to p if necessary:
          if(size(p)==0) {ind = 1; p[ind]=fac[1][k];}
          else
          {
            for(ind=1;1;ind++)
            {
              if(p[ind]==fac[1][k]) {break;}
              if(ind==size(p))
              {
                ind++;
                p[ind]=fac[1][k];
                break;
              }
            }
          }
          factors[size(factors)+1] = ind;
          exponents[size(exponents)+1] = fac[2][k];
          fac[1] = delete(fac[1],k);
          fac[2] = delete(fac[2],k);
          continue;
        }
      }
      fractions[i][j][2] = fac;
      nonlin_denom_factors[i][j] = list(factors,exponents);
    }
    dbprint(sprintf("  row %s done! (%s ms)", i, rtimer-t0));
  }
  return(fractions, nonlin_denom_factors, p);
}

proc checkpfdMat(def input, string output, string qfile, list #)
"USAGE:   checkpfdMat(input, output, denomFactors[, N, parallelize]);
          input,output,denomFactors string, N,parallelize int
PURPOSE:  test the output files of @code{pfdMat} for correctness. Input and
          output (indexed) txt-files have to be given as strings in the form
          \"@code{<path-to-file>/<filename>.txt}\". The output should be indexed
          (that is the output file ending in @code{..._pfd_indexed.txt}) and
          @code{denomFactors} has to be the file containing the denominator
          factors @code{q1}, @code{q2}, ... (the txt-file ending in
          @code{..._denominator_factors.txt}).
       @* As for @code{readInputTXT} and @code{pfdMat}, the basering has to
          match the variable names used in the input file, which has to be in
          the same format specified in @ref{readInputTXT}. Also, files bigger
          than 2 GB have to be split as described for @code{readInputTXT} and a
          list of filenames can be given as first argument instead.
       @* If a positive integer N is given, the test is done probabilistically by
          evaluation at N random points for each entry of the matrix. If N is
          nonpositive (default), the fractions in the decompositions will be
          expanded symbolically and compared to the input (may be slower).
       @* If @code{parallelize} is nonzero (default), the tests are run in
          parallel using @ref{parallel_lib}.
       @* The result is printed and as in @code{pfdMat} a logfile is created
          showing the results for each matrix entry.
SEE ALSO: readInputTXT, pfd, checkpfd, pfdMat
"
{
  system("--ticks-per-sec",1000);
  short = 0;
  int t0;
  int N=0;
  int parallelize=1;
  if(size(#)==1)
  {
    if(typeof(#[1])=="int") {N=#[1];}
    else {ERROR("invalid argument type: "+typeof(#[1]));}
  }
  if(size(#)==2)
  {
    if(typeof(#[1])=="int" && typeof(#[2])=="int")
      {N=#[1]; parallelize=#[2];}
    else {ERROR("invalid argument types: "+typeof(#[1])+", "+typeof(#[2]));}
  }
  if(size(#)>2) {ERROR("too many arguments");}

  dbprint(newline+"reading input file:");
  printlevel = printlevel+1;
  list frac = readInputTXT(input,2);
  printlevel = printlevel-1;
  if(typeof(input)=="string") {string filename=input;}
  if(typeof(input)=="list")   {string filename=input[1];}
  filename = filename[1,find(filename,".txt")-1];

  dbprint("factorizing the denominators "); t0=rtimer;
  printlevel = printlevel+1;
  frac = FactDenom(frac);
  printlevel = printlevel-1;
  dbprint(sprintf("done! (%s ms)",rtimer-t0));

  dbprint("reading output files:"); t0=rtimer;
  dbprint(" reading list of denominator factors from "+qfile);
  ideal q;
  q = readQfileTXT(qfile);
  dbprint(" done!");

  dbprint(" reading (indexed) output decompositions ");
  list dec,nonlin;
  printlevel = printlevel+1;
  dec,nonlin = readOutputTXT_indexed(output);
  printlevel = printlevel-1;

  if(parallelize)
    {dbprint(sprintf("done! (%s ms)%n%ncreating tasks",rtimer-t0,0)); t0=rtimer;}
  else
  {
    dbprint(sprintf("done! (%s ms)%n",rtimer-t0,0));
    if(N<=0)
      {dbprint("checking for correctness (exact test) ");}
    else
      {dbprint(sprintf("checking for correctness (%s random evaluations per entry) ",N));}
    t0=rtimer;
  }

  fprintf(":w "+filename+"_checkpfdMat_logfile.txt","Input file (matrix of rational functions):"
          +" %s%nOutput file (decompositions): %s%nlist of all denominator factors:"
          +" %s%n%nResults of checkpfdMat:",input,output,qfile,0);
  link logfile = ":a "+filename+"_checkpfdMat_logfile.txt";

  int n=size(frac);
  int m=size(frac[1]);
  int i,j,k,ind;
  list arguments;
  for(i=1;i<=n;i++)
  {
    for(j=1;j<=m;j++)
    {
      for(k=1;k<=size(nonlin[i][j][1]);k++)
      {
        ind = find_entry(frac[i][j][2][1],q[nonlin[i][j][1][k]]);
        if(ind==0) {ERROR("nonlinear factors are wrong");}
        if(frac[i][j][2][2][ind]!=nonlin[i][j][2][k])
          {ERROR("nonlinear factors are wrong");}
        frac[i][j][2][1] = delete(frac[i][j][2][1],ind);
        frac[i][j][2][2] = delete(frac[i][j][2][2],ind);
      }
      if(parallelize)
        {arguments[(i-1)*m+j] = list(i,j,frac[i][j],list(q,dec[i][j]),logfile,N);}
      else
        {results[(i-1)*m+j] = testEntry(i,j,frac[i][j],list(q,dec[i][j]),logfile,N);}
    }
  }

  if(parallelize)
  {
    dbprint(sprintf("done! (%s ms)%n",rtimer-t0,0));
    if(N<=0)
      {dbprint("checking for correctness (exact test) ");}
    else
      {dbprint(sprintf("checking for correctness (%s random evaluations per entry) ",N));}
    t0=rtimer;
    list results = parallelWaitAll("testEntry",arguments);
  }
  else {dbprint(sprintf("done! (%s ms)",rtimer-t0));}
  dbprint(sprintf("%s out of %s = %sx%s decompositions are correct! (%s ms)%n",
          sum(results),n*m,n,m,rtimer-t0,0));
  fprintf(logfile,"%s out of %s = %sx%s decompositions are correct! (%s ms)%n",
          sum(results),n*m,n,m,rtimer-t0,0);
}

static proc readOutputTXT_indexed(string filename__)
{
  system("--ticks-per-sec",1000);
  dbprint("  reading matrix of decompositions from file "+filename__);
  int t__=rtimer;
  int tt__;
  string data__ = read(":r "+filename__);
  dbprint(sprintf("  done! (%s ms)", rtimer-t__));

  dbprint("  processing input "); t__ = rtimer;
  list mat__;
  list nonlin__=list();
  int left__,right__=0,0;
  left__ = find(data__,"{");
  int pos1__,pos2__=0,0;
  int p1__,p2__;
  int tmp__,tmp2__,depth__;
  int i__,j__,k__,l__,max__;
  intvec factors__,exponents__;
  poly numerator__;
  string s__,ss__;
  for(i__=1;1;i__++)
  {
    tt__ = rtimer;
    left__ = find(data__,"{",left__+1);
    if(left__==0) {break;}
    right__ = find(data__,"}",left__);
    mat__[i__]=list();
    nonlin__[i__]=list();
    pos2__=left__;
    for(j__=1;pos2__<right__&&pos2__>0;j__++)
    {
      pos1__ = pos2__+1;
      pos2__ = find(data__,",",pos1__);
      if(pos2__==0||pos2__>right__) {s__ = data__[pos1__,right__-pos1__];}
      else {s__ = data__[pos1__,pos2__-pos1__];}
      mat__[i__][j__] = list();

      factors__ = intvec(0:0);
      exponents__ = intvec(0:0);
      l__ = find(s__," * ");
      if(l__>0)
      {
        ss__ = s__[1,l__-1];    //ss__ contains the nonlinear factors
        s__ = s__[l__+3,size(s__)-l__-2];
        for(p1__=1;s__[p1__]!="(";p1__++) {}
        for(p2__=size(s__);s__[p2__]!=")";p2__--) {}
        s__ = s__[p1__+1,p2__-p1__-1];
        l__ = find(ss__,"q");
        ss__ = ss__[l__,find(ss__,")",l__)-l__];
        ss__ = ss__+"*";
        p1__=0;
        for(l__=1;1;l__++)
        {
          p1__ = find(ss__,"q",p1__+1);
          if(p1__==0) {break;}
          p1__++;
          p2__ = find(ss__,"^",p1__);
          tmp__ = find(ss__,"*",p1__);
          if((p2__>tmp__ && tmp__>0) || (p2__==0))    //exponent is 1
          {
            execute("factors__[l__]="+ss__[p1__,tmp__-p1__]);
            exponents__[l__] = 1;
          }
          else
          {
            execute("factors__[l__]="+ss__[p1__,p2__-p1__]);
            execute("exponents__[l__]="+ss__[p2__+1,tmp__-p2__-1]);
          }
        }
      }
      nonlin__[i__][j__] = list(factors__,exponents__);

      depth__ = 0;
      s__=s__+" ";
      max__ = size(s__);
      tmp__ = 1;
      tmp2__ = 0;
      for(k__=1;k__<=max__;k__++)
      {
        if(s__[k__]=="(") {depth__++;k__++;continue;}
        if(s__[k__]==")") {depth__--;k__++;continue;}
        if(s__[k__]=="/" && depth__==0) {tmp2__ = k__;}
        if((s__[k__]=="+" && depth__==0) || k__==max__)
        {
          if(tmp2__==0)    // no denominator
          {
            execute("numerator__="+s__[tmp__,k__-tmp__]);
            mat__[i__][j__][size(mat__[i__][j__])+1] = list(numerator__,intvec(0:0),intvec(0:0));
            tmp__ = k__+1;
            k__++; continue;
          }
          execute("numerator__="+s__[tmp__,tmp2__-tmp__]);
          ss__ = s__[tmp2__+1,k__-tmp2__-1];
          p1__ = find(ss__,"(");
          p2__ = find(ss__,")");
          ss__ = ss__[p1__+1,p2__-p1__-1];   // now ss__ is only the denominator

          ss__ = ss__+"*";
          factors__ = intvec(0:0);
          exponents__ = intvec(0:0);
          p1__=0;
          for(l__=1;1;l__++)
          {
            p1__ = find(ss__,"q",p1__+1);
            if(p1__==0) {break;}
            p1__++;
            p2__ = find(ss__,"^",p1__);
            tmp__ = find(ss__,"*",p1__);
            if((p2__>tmp__ && tmp__>0) || (p2__==0))    //exponent is 1
            {
              execute("factors__[l__]="+ss__[p1__,tmp__-p1__]);
              exponents__[l__] = 1;
            }
            else
            {
              execute("factors__[l__]="+ss__[p1__,p2__-p1__]);
              execute("exponents__[l__]="+ss__[p2__+1,tmp__-p2__-1]);
            }
          }
          mat__[i__][j__][size(mat__[i__][j__])+1] = list(numerator__,factors__,exponents__);
          tmp__ = k__+1;
          tmp2__ = 0;
        }
      }
    }
    dbprint(sprintf("    row %s done! (%s ms)",i__,rtimer-tt__));
  }
  dbprint(sprintf("  done! (%s ms)", rtimer-t__));

  return(mat__,nonlin__);
}

static proc readOutputTXT(string filename__)
{
  system("--ticks-per-sec",1000);
  dbprint("  reading matrix of decompositions from file "+filename__);
  int t__=rtimer;
  int tt__;
  string data__ = read(":r "+filename__);
  dbprint(sprintf("  done! (%s ms)", rtimer-t__));

  dbprint("  processing input "); t__ = rtimer;
  list mat__;
  list nonlin__=list();
  int left__,right__=0,0;
  left__ = find(data__,"{");
  int pos1__,pos2__=0,0;
  int p1__,p2__;
  int tmp__,tmp2__,depth__;
  int i__,j__,k__,l__,max__,ind__;
  ideal q__;
  poly f__;
  intvec factors__,exponents__;
  poly numerator__;
  string s__,ss__;
  for(i__=1;1;i__++)
  {
    tt__ = rtimer;
    left__ = find(data__,"{",left__+1);
    if(left__==0) {break;}
    right__ = find(data__,"}",left__);
    mat__[i__]=list();
    nonlin__[i__]=list();
    pos2__=left__;
    for(j__=1;pos2__<right__&&pos2__>0;j__++)
    {
      pos1__ = pos2__+1;
      pos2__ = find(data__,",",pos1__);
      if(pos2__==0||pos2__>right__) {s__ = data__[pos1__,right__-pos1__];}
      else {s__ = data__[pos1__,pos2__-pos1__];}
      mat__[i__][j__] = list();

      factors__ = intvec(0:0);
      exponents__ = intvec(0:0);
      l__ = find(s__," * ");
      if(l__>0)
      {
        ss__ = s__[1,l__-1];    //ss__ contains the nonlinear factors
        s__ = s__[l__+3,size(s__)-l__-2];
        for(p1__=1;s__[p1__]!="(";p1__++) {}
        for(p2__=size(s__);s__[p2__]!=")";p2__--) {}
        s__ = s__[p1__+1,p2__-p1__-1];

        //l__ = find(ss__,"q");
        //ss__ = ss__[l__,find(ss__,")",l__)-l__];
        for(p2__=size(ss__);ss__[p2__]!=")";p2__--) {}
        l__ = find(ss__,"/(")+2;
        ss__ = ss__[l__,p2__-l__];

        ss__ = ss__+"*";
        p1__=0;
        for(l__=1;1;l__++)
        {
          p1__ = find(ss__,"(",p1__+1);
          if(p1__==0) {break;}
          p1__++;
          p2__ = find(ss__,")",p1__);
          tmp__ = find(ss__,"*",p2__);

          execute("f__="+ss__[p1__,p2__-p1__]);
          ind__ = find_entry(q__,f__);
          if(ind__==0) {ind__=size(q__)+1; q__[ind__]=f__;}
          factors__[l__] = ind__;

          if(tmp__==p2__+1)    //exponent is 1
          {
            exponents__[l__] = 1;
          }
          else {if(ss__[p2__+1]=="^")
          {
            execute("exponents__[l__]="+ss__[p2__+2,tmp__-p2__-2]);
          }
          else {ERROR("Wrong input format");}}
        }
      }
      nonlin__[i__][j__] = list(factors__,exponents__);

      depth__ = 0;
      s__=s__+" ";
      max__ = size(s__);
      tmp__ = 1;
      tmp2__ = 0;
      for(k__=1;k__<=max__;k__++)
      {
        if(s__[k__]=="(") {depth__++;k__++;continue;}
        if(s__[k__]==")") {depth__--;k__++;continue;}
        if(s__[k__]=="/" && depth__==0) {tmp2__ = k__;}
        if((s__[k__]=="+" && depth__==0) || k__==max__)
        {
          if(tmp2__==0)    // no denominator
          {
            execute("numerator__="+s__[tmp__,k__-tmp__]);
            mat__[i__][j__][size(mat__[i__][j__])+1] = list(numerator__,intvec(0:0),intvec(0:0));
            tmp__ = k__+1;
            k__++; continue;
          }
          execute("numerator__="+s__[tmp__,tmp2__-tmp__]);
          ss__ = s__[tmp2__+2,k__-tmp2__-2];
          for(p2__=size(ss__);ss__[p2__]!=")";p2__--) {}
          ss__ = ss__[1,p2__-1];  // now ss__ is only the denominator

          ss__ = ss__+"*";
          factors__ = intvec(0:0);
          exponents__ = intvec(0:0);
          p1__=0;

          /*
          for(l__=1;1;l__++)
          {
            p1__ = find(ss__,"q",p1__+1);
            if(p1__==0) {break;}
            p1__++;
            p2__ = find(ss__,"^",p1__);
            tmp__ = find(ss__,"*",p1__);
            if((p2__>tmp__ && tmp__>0) || (p2__==0))    //exponent is 1
            {
              execute("factors__[l__]="+ss__[p1__,tmp__-p1__]);
              exponents__[l__] = 1;
            }
            else
            {
              execute("factors__[l__]="+ss__[p1__,p2__-p1__]);
              execute("exponents__[l__]="+ss__[p2__+1,tmp__-p2__-1]);
            }
          }
          */

          for(l__=1;1;l__++)
          {
            p1__ = find(ss__,"(",p1__+1);
            if(p1__==0) {break;}
            p1__++;
            p2__ = find(ss__,")",p1__);
            tmp__ = find(ss__,"*",p2__);

            execute("f__="+ss__[p1__,p2__-p1__]);
            ind__ = find_entry(q__,f__);
            if(ind__==0) {ind__=size(q__)+1; q__[ind__]=f__;}
            factors__[l__] = ind__;

            if(tmp__==p2__+1)    //exponent is 1
            {
              exponents__[l__] = 1;
            }
            else {if(ss__[p2__+1]=="^")
            {
              execute("exponents__[l__]="+ss__[p2__+2,tmp__-p2__-2]);
            }
            else {ERROR("Wrong input format");}}
          }


          mat__[i__][j__][size(mat__[i__][j__])+1] = list(numerator__,factors__,exponents__);
          tmp__ = k__+1;
          tmp2__ = 0;
        }
      }
    }
    dbprint(sprintf("    row %s done! (%s ms)",i__,rtimer-tt__));
  }
  dbprint(sprintf("  done! (%s ms)", rtimer-t__));

  return(mat__,nonlin__,q__);
}

static proc readQfileTXT(string filename__)
{
  string data__ = read(":r "+filename__);
  ideal q__;
  int pos1__,pos2__=1,1;
  while(1)
  {
    pos1__=find(data__,"=",pos2__);
    if(pos1__==0) {break;}
    pos1__++;
    pos2__=find(data__,";",pos1__);
    execute("q__[size(q__)+1]="+data__[pos1__,pos2__-pos1__]);
  }
  return(q__);
}


// Test of matrix multiplication with partfrac data types //////////////////////

proc testmat_read_txt(int mode)
{
  ring r = 0,(ep, m44, s, t),dp;
  list mat1,mat2,mat3, nonlin1,nonlin2,nonlin3, terms;
  ideal q1,q2,q3;
  system("--ticks-per-sec",1000);
  int t=rtimer;

  if(mode==1)
  {
    printlevel = printlevel+1;
    mat1,nonlin1,q1 = readOutputTXT("m1.txt");
    mat2,nonlin2,q2 = readOutputTXT("m2.txt");
    mat3,nonlin3,q3 = readOutputTXT("m3.txt");
    printlevel = printlevel-1;

    printf("%nsaving to ssi",0); t = rtimer;
    write("ssi:w m1_original.ssi",list(q1,mat1,nonlin1));
    write("ssi:w m2_original.ssi",list(q2,mat2,nonlin2));
    write("ssi:w m3_original.ssi",list(q3,mat3,nonlin3));
    printf("done (%sms)",rtimer-t); t = rtimer;
  }
  else
  {
    printf("%nreading from ssi",0); t = rtimer;
    list l;
    l = read("ssi:r m1_original.ssi"); q1=l[1]; mat1=l[2]; nonlin1=l[3];
    l = read("ssi:r m2_original.ssi"); q2=l[1]; mat2=l[2]; nonlin2=l[3];
    l = read("ssi:r m3_original.ssi"); q3=l[1]; mat3=l[2]; nonlin3=l[3];
    kill l;
    printf("done (%sms)",rtimer-t); t = rtimer;
  }

  int i,j,k,l,s;
  printf("%njoining linear and nonlinear factors",0);
  for(i=1;i<=size(mat1);i++)
  {
    for(j=1;j<=size(mat1[i]);j++)
    {
      for(k=1;k<=size(mat1[i][j]);k++)
      {
        s = size(mat1[i][j][k][2]);
        for(l=1;l<=size(nonlin1[i][j][1]);l++)
        {
          mat1[i][j][k][2][s+l] = nonlin1[i][j][1][l];
          mat1[i][j][k][3][s+l] = nonlin1[i][j][2][l];
        }
      }
    }
  }
  printf("done m1 (%sms)",rtimer-t); t = rtimer;
  for(i=1;i<=size(mat2);i++)
  {
    for(j=1;j<=size(mat2[i]);j++)
    {
      for(k=1;k<=size(mat2[i][j]);k++)
      {
        s = size(mat2[i][j][k][2]);
        for(l=1;l<=size(nonlin2[i][j][1]);l++)
        {
          mat2[i][j][k][2][s+l] = nonlin2[i][j][1][l];
          mat2[i][j][k][3][s+l] = nonlin2[i][j][2][l];
        }
      }
    }
  }
  printf("done m2 (%sms)",rtimer-t); t = rtimer;
  for(i=1;i<=size(mat3);i++)
  {
    for(j=1;j<=size(mat3[i]);j++)
    {
      for(k=1;k<=size(mat3[i][j]);k++)
      {
        s = size(mat3[i][j][k][2]);
        for(l=1;l<=size(nonlin3[i][j][1]);l++)
        {
          mat3[i][j][k][2][s+l] = nonlin3[i][j][1][l];
          mat3[i][j][k][3][s+l] = nonlin3[i][j][2][l];
        }
      }
    }
  }
  printf("done m3 (%sms)",rtimer-t); t = rtimer;

  printf("%nsaving to ssi",0);
  write("ssi:w m1.ssi",list(q1,mat1));
  write("ssi:w m2.ssi",list(q2,mat2));
  write("ssi:w m3.ssi",list(q3,mat3));
  printf("done (%sms)",rtimer-t); t = rtimer;

  printf("%napplying pfd",0);
  for(i=1;i<=size(mat1);i++)
  {
    for(j=1;j<=size(mat1[i]);j++)
    {
      terms = mat1[i][j];
      mat1[i][j] = main_part_of_pfd(q1,terms,0,0,link(""))[2];
    }
  }
  printf("done m1 (%sms)",rtimer-t); t = rtimer;
  for(i=1;i<=size(mat2);i++)
  {
    for(j=1;j<=size(mat2[i]);j++)
    {
      terms = mat2[i][j];
      mat2[i][j] = main_part_of_pfd(q2,terms,0,0,link(""))[2];
    }
  }
  printf("done m2 (%sms)",rtimer-t); t = rtimer;
  for(i=1;i<=size(mat3);i++)
  {
    for(j=1;j<=size(mat3[i]);j++)
    {
      terms = mat3[i][j];
      mat3[i][j] = main_part_of_pfd(q3,terms,0,0,link(""))[2];
    }
  }
  printf("done m3 (%sms)",rtimer-t); t = rtimer;

  printf("%nsaving to ssi",0);
  write("ssi:w m1_pfd.ssi",list(q1,mat1));
  write("ssi:w m2_pfd.ssi",list(q2,mat2));
  write("ssi:w m3_pfd.ssi",list(q3,mat3));
  printf("done (%sms)",rtimer-t); t = rtimer;
}

proc matrix_multiplication(list M, list N, list #)
"PURPOSE: Matrix-Matrix-multiplication for list-of-lists matrices  with
          entries of arbitrary type which supports addition and multiplication.
"
{
  if(parallelize_matrix_multiplication)
  {
    list arguments;
    int i,j;
    for(i=1;i<=size(M);i++)
    {
      if(size(#)>0) {arguments[i] = list(list(M[i]),N,list(#[i]),i);}
      else {arguments[i] = list(list(M[i]),N);}
    }
    list results = parallelWaitAll("matrix_multiplication_parallel",arguments);
    int counter = 0;
    for(i=1;i<=size(M);i++)
    {
      if(size(#)>0)
      {
        counter = counter + results[i][2];
        results[i] = results[i][1][1];
      }
      else
      {
        results[i] = results[i][1];
      }
    }
    if(size(#)>0) {return(results,counter);}
    return(results);
  }
  else
  {
    link ll = ":w matrix_product_"+datetime()+".txt";
    if(size(#)>0)
      {list results = matrix_multiplication_parallel(M,N,#,ll);}
    else
      {list results = matrix_multiplication_parallel(M,N);}
    return(results[1],results[2]);
  }
}

static proc matrix_multiplication_parallel(list M, list N, list #)
{
  system("--ticks-per-sec",1000);
  int compare = 0;
  int counter,scounter1,scounter2,sscounter1,sscounter2;
  int size1,size2;
  if(size(#)>0)
  {
    compare = 1;     // result will be compared to the matrix # / #[1]
    if(typeof(#[2])=="link") {link ll = #[2];}
    else {link ll = ":w matrix_product_row_"+string(#[2])+"_"+datetime()+".txt";}
    # = #[1];
  }
  if(size(M[1])!=size(N)) {ERROR("Matrix dimensions do not agree.");}
  int i,j,k;
  list result;
  int t = rtimer;
  for(i=1;i<=size(M);i++)
  {
    result[i] = list();
    for(j=1;j<=size(N[1]);j++)
    {
      result[i][j] = M[i][1]*N[1][j];
      for(k=2;k<=size(N);k++)
      {
        result[i][j] = result[i][j] + M[i][k]*N[k][j];
      }
      if(compare) // compare result componentwise to #
      {
        k = (result[i][j]==#[i][j]);
        counter = counter+k;
        fprintf(ll,"_[%s,%s]: %s (in total: %s/%s correct) (%sms)",i,j,k,counter,(i-1)*size(N[1])+j,rtimer-t); t=rtimer;
        size1, size2 = size(result[i][j]),size(#[i][j]);
        scounter1 = scounter1+size1; scounter2 = scounter2+size2;
        fprintf(ll," size: %s to %s  (in total: %s to %s) (%sms)",size1,size2,scounter1,scounter2,rtimer-t); t=rtimer;
        size1, size2 = size(string(result[i][j])),size(string(#[i][j]));
        sscounter1 = sscounter1+size1; sscounter2 = sscounter2+size2;
        fprintf(ll," stringsize: %s to %s  (in total: %s to %s) (%sms)",size1,size2,sscounter1,sscounter2,rtimer-t); t=rtimer;
      }
    }
  }
  if(compare) {return(list(result,counter));}
  return(result);
}

proc transp(list M)
{
  list MT;
  int i,j;
  int n,m = size(M), size(M[1]); // M = n-by-m matrix
  for(i=1; i<=m; i++)
  {
    MT[i] = list();
    for(j=1; j<=n; j++)
    {
      MT[i][j] = M[j][i];
    }
  }
  return(MT);
}

proc testmat(int mode)
{
  write(":w testmat_log.txt","");
  link file_link = ":a testmat_log.txt";

  ring r = 0,(ep, m44, s, t),dp;
  system("--ticks-per-sec",1000);
  int t = rtimer;
  fprintf(file_link,"reading from ssi");
  ideal q1,q2,q3;
  list l, m1,m2,m3, m1_pf,m2_pf,m3_pf, m1_pf2,m2_pf2,m3_pf2, m1_rat,m2_rat,m3_rat;
  if(mode==1)
  {
    l = read("ssi:r m1.ssi"); q1=l[1]; m1=l[2];
    l = read("ssi:r m2.ssi"); q2=l[1]; m2=l[2];
    l = read("ssi:r m3.ssi"); q3=l[1]; m3=l[2];
  }
  else{if(mode==2)
  {
    l = read("ssi:r m1_pfd.ssi"); q1=l[1]; m1=l[2];
    l = read("ssi:r m2_pfd.ssi"); q2=l[1]; m2=l[2];
    l = read("ssi:r m3_pfd.ssi"); q3=l[1]; m3=l[2];
  }
  else{if(mode==3 || mode==4)
  {
    if(mode==3)
    {
      l = read("ssi:r m1.ssi"); q1=l[1]; m1=l[2];
      l = read("ssi:r m2.ssi"); q2=l[1]; m2=l[2];
      l = read("ssi:r m3.ssi"); q3=l[1]; m3=l[2];
    }
    else
    {
      l = read("ssi:r m1_pfd.ssi"); q1=l[1]; m1=l[2];
      l = read("ssi:r m2_pfd.ssi"); q2=l[1]; m2=l[2];
      l = read("ssi:r m3_pfd.ssi"); q3=l[1]; m3=l[2];
    }

    m1_pf = read("ssi:r mode_"+string(mode-2)+"_m1_partfrac.ssi");
    m2_pf = read("ssi:r mode_"+string(mode-2)+"_m2_partfrac.ssi");
    m3_pf = read("ssi:r mode_"+string(mode-2)+"_m3_partfrac.ssi");
    l = read("ssi:r mode_"+string(mode-2)+"_m1_partfrac2.ssi"); m1_pf2=l[2];
    l = read("ssi:r mode_"+string(mode-2)+"_m2_partfrac2.ssi"); m2_pf2=l[2];
    l = read("ssi:r mode_"+string(mode-2)+"_m3_partfrac2.ssi"); m3_pf2=l[2];
    setq(l[1]);

    m1_rat = read("ssi:r mode_"+string(mode-2)+"_m1_rational.ssi");
    m2_rat = read("ssi:r mode_"+string(mode-2)+"_m2_rational.ssi");
    m3_rat = read("ssi:r mode_"+string(mode-2)+"_m3_rational.ssi");
    def R = basering;
    setring(r);
  }
  else {ERROR("invalid input");}}}
  kill l;
  fprintf(file_link,"done (%sms)",rtimer-t); t=rtimer;

  if(mode==1 || mode==2)
  {
    fprintf(file_link,"creating matrices of partfrac/partfrac2 objects");
    int i,j,k;
    for(i=1;i<=size(m1);i++)
    {
      m1_pf[i] = list();
      m1_pf2[i] = list();
      for(j=1;j<=size(m1[i]);j++)
      {
        printf(" %s,%s: %s",i,j,size(m1[i][j]));
        m1_pf[i][j] = makepfd(q1,m1[i][j]);
        //m1_pf2[i][j] = makepfd2(q1,m1[i][j]);
        m1_pf[i][j] = makepfd(numerator(m1_pf[i][j]), denominator(m1_pf[i][j]));
        m1_pf2[i][j] = makepfd2(m1_pf[i][j]);
      }
    }
    fprintf(file_link,"done m1 (%sms)",rtimer-t); t=rtimer;
    for(i=1;i<=size(m2);i++)
    {
      m2_pf[i] = list();
      m2_pf2[i] = list();
      for(j=1;j<=size(m2[i]);j++)
      {
        printf(" %s,%s: %s",i,j,size(m2[i][j]));
        m2_pf[i][j] = makepfd(q2,m2[i][j]);
        //m2_pf2[i][j] = makepfd2(q2,m2[i][j]);
        m2_pf[i][j] = makepfd(numerator(m2_pf[i][j]), denominator(m2_pf[i][j]));
        m2_pf2[i][j] = makepfd2(m2_pf[i][j]);
      }
    }
    fprintf(file_link,"done m2 (%sms)",rtimer-t); t=rtimer;
    for(i=1;i<=size(m3);i++)
    {
      m3_pf[i] = list();
      m3_pf2[i] = list();
      for(j=1;j<=size(m3[i]);j++)
      {
        printf(" %s,%s: %s",i,j,size(m3[i][j]));
        m3_pf[i][j] = makepfd(q3,m3[i][j]);
        //m3_pf2[i][j] = makepfd2(q3,m3[i][j]);
        m3_pf[i][j] = makepfd(numerator(m3_pf[i][j]), denominator(m3_pf[i][j]));
        m3_pf2[i][j] = makepfd2(m3_pf[i][j]);
      }
    }
    fprintf(file_link,"done m3 (%sms)",rtimer-t); t=rtimer;

    fprintf(file_link,"saving to ssi");
    write("ssi:w mode_"+string(mode)+"_m1_partfrac.ssi",m1_pf);
    write("ssi:w mode_"+string(mode)+"_m2_partfrac.ssi",m2_pf);
    write("ssi:w mode_"+string(mode)+"_m3_partfrac.ssi",m3_pf);
    write("ssi:w mode_"+string(mode)+"_m1_partfrac2.ssi",list(getq(),m1_pf2));
    write("ssi:w mode_"+string(mode)+"_m2_partfrac2.ssi",list(getq(),m2_pf2));
    write("ssi:w mode_"+string(mode)+"_m3_partfrac2.ssi",list(getq(),m3_pf2));

    fprintf(file_link,"creating matrices of rational functions");
    poly num,denom;
    for(i=1;i<=size(m1);i++)
    {
      m1_rat[i] = list();
      for(j=1;j<=size(m1[i]);j++)
      {
        num, denom = numdenompfd(m1_pf[i][j]);
        m1_rat[i][j] = list(num,denom);
      }
    }
    for(i=1;i<=size(m2);i++)
    {
      m2_rat[i] = list();
      for(j=1;j<=size(m2[i]);j++)
      {
        num, denom = numdenompfd(m2_pf[i][j]);
        m2_rat[i][j] = list(num,denom);
      }
    }
    for(i=1;i<=size(m3);i++)
    {
      m3_rat[i] = list();
      for(j=1;j<=size(m3[i]);j++)
      {
        num, denom = numdenompfd(m3_pf[i][j]);
        m3_rat[i][j] = list(num,denom);
      }
    }
    ring R=r,t__,dp; setring(R);
    //ring R = (0,ep,m44,s,t),t__,dp; setring(R);
    list m1_rat = imap(r,m1_rat);
    list m2_rat = imap(r,m2_rat);
    list m3_rat = imap(r,m3_rat);
    for(i=1;i<=size(m1_rat);i++)
    {
      for(j=1;j<=size(m1_rat[i]);j++)
      {
        m1_rat[i][j] = number(m1_rat[i][j][1])/number(m1_rat[i][j][2]);
      }
    }
    for(i=1;i<=size(m2_rat);i++)
    {
      for(j=1;j<=size(m2_rat[i]);j++)
      {
        m2_rat[i][j] = number(m2_rat[i][j][1])/number(m2_rat[i][j][2]);
      }
    }
    for(i=1;i<=size(m3_rat);i++)
    {
      for(j=1;j<=size(m3_rat[i]);j++)
      {
        m3_rat[i][j] = number(m3_rat[i][j][1])/number(m3_rat[i][j][2]);
      }
    }

    link l1 = "ssi:w mode_"+string(mode)+"_m1_rational.ssi";
    link l2 = "ssi:w mode_"+string(mode)+"_m2_rational.ssi";
    link l3 = "ssi:w mode_"+string(mode)+"_m3_rational.ssi";
    write(l1,m1_rat);
    write(l2,m2_rat);
    write(l3,m3_rat);
    setring(r);
    fprintf(file_link,"done (%sms)",rtimer-t); t=rtimer;
  }

  int counter;
  list prod_pf, prod_pf2, prod_rat;
  int nentries = size(m3)*size(m3[1]);

  fprintf(file_link,"product with partfrac");
  prod_pf,counter = matrix_multiplication(transp(m2_pf),transp(m1_pf),transp(m3_pf));
  fprintf(file_link,"done (%sms, %s/%s correct)",rtimer-t,counter,nentries); t=rtimer;

  fprintf(file_link,"saving to ssi");
  write("ssi:w mode_"+string(mode)+"_prod_partfrac.ssi",transp(prod_pf));
  fprintf(file_link,"done (%sms)",rtimer-t); t=rtimer;


  fprintf(file_link,"product with partfrac2");
  prod_pf2,counter = matrix_multiplication(transp(m2_pf2),transp(m1_pf2),transp(m3_pf2));
  fprintf(file_link,"done (%sms, %s/%s correct)",rtimer-t,counter,nentries); t=rtimer;

  fprintf(file_link,"saving to ssi");
  write("ssi:w mode_"+string(mode)+"_prod_partfrac2.ssi",list(getq(),transp(prod_pf2)));
  fprintf(file_link,"done (%sms)",rtimer-t); t=rtimer;


  setring(R);
  fprintf(file_link,"product with rational functions");
  prod_rat,counter = matrix_multiplication(m1_rat,m2_rat,m3_rat);
  fprintf(file_link,"done (%sms, %s/%s correct)",rtimer-t,counter,nentries); t=rtimer;

  fprintf(file_link,"saving to ssi");
  write("ssi:w mode_"+string(mode)+"_prod_rat.ssi",prod_rat);
  fprintf(file_link,"done (%sms)",rtimer-t); t=rtimer;
  setring(r);
}


// Test ////////////////////////////////////////////////////////////////////////

static proc file_exists(string file)
{
  return(status(":r "+file,"exists","yes"));
}


proc pfdSingleEntry(string filename, list #)
"USAGE:   pfdSingleEntry(filename[,from_dir,to_dir]), filename,from_dir,to_dir string
PURPOSE:  apply pfd to the rational function saved in @code{file}.
          @code{filename} is the name (no file ending) of a txt-file containing
          the rational function as a string or an ssi-file containing a
          two-element list of numerator and denominator polynomials.
          The result will be safed as txt- and ssi-files.
          @code{rom_dir} and @{to_dir} are the directories of the input and
          output files respectively (default: current directory).
SEE ALSO: pfdMat
"
{
  system("--ticks-per-sec",1000);
  short = 0;
  if(size(#)>0)
  {
    string from_dir = #[1]; // read file from this
    if(from_dir[size(from_dir)]!="/") {from_dir = from_dir + "/";}
  }
  else {string from_dir = "";}
  if(size(#)>1)
  {
    string to_dir = #[2];
    if(to_dir[size(to_dir)]!="/") {to_dir = to_dir + "/";}
  }
  else {string to_dir = "";}

  if(file_exists(to_dir+"resources_"+filename+".txt")) {return();}

  int i,j,k;
  list fraction;
  i = find(filename,".");
  if(i>0) {filename = filename[1,i-1];} // remove file ending if given

  if(file_exists(from_dir+filename+".ssi"))
  {
    fraction = read("ssi:r "+from_dir+filename+".ssi");
  }
  else
  {
    string s = read(":r "+from_dir+filename+".txt");
    string s1,s2;
    j = find(s,"/(");
    if(j==0) // no denominator
    {
      fraction = list(string_to_poly(s), poly(1));
    }
    else
    {
      s1 = s[1,j-1];
      s2 = s[j+1,size(s)-j];
      fraction = list(string_to_poly(s1), string_to_poly(s2));
    }

    list fact = factorize(fraction[2]);

    number lcoeff;
    number constant = number(fact[1][1])^fact[2][1];
    fact[1] = delete(fact[1],1);
    fact[2] = delete(fact[2],1);
    for(k=1; k<=size(fact[1]); k++)
    {
      lcoeff = leadcoef(fact[1][k]);
      fact[1][k] = fact[1][k]/lcoeff;
      constant = constant*(lcoeff^fact[2][k]); // polynomial is monic (thus unique)
      lcoeff = content(fact[1][k]);
      fact[1][k] = fact[1][k]/lcoeff;
      constant = constant*(lcoeff^fact[2][k]); // polynomial has nice coefficients
    }

    fraction[1] = fraction[1] * (1/constant);
    fraction[2] = fact;

    write("ssi:w "+from_dir+filename+".ssi", fraction);
  }

  list nonlin = list(list(),list());
  i = 1;
  for(k=1; k<=size(fraction[2][1]); k++) // move nonlinear factors into nonlin
  {
    if(deg(fraction[2][1][k])>1)
    {
      nonlin[1][i] = fraction[2][1][k];
      nonlin[2][i] = fraction[2][2][k];
      fraction[2][1] = delete(fraction[2][1],k);
      fraction[2][2] = delete(fraction[2][2],k);
      i++;
    }
  }

  int t = rtimer;
  list result = pfd(fraction);
  t = rtimer-t;

  // output as Singular objects
  write("ssi:w "+to_dir+"result_"+filename+".ssi",list(nonlin,result));

  //output as txt:
  string dec;
  string nonlin_fact;
  k = size(nonlin[1]);

  dec = getStringpfd(result);
  if(k>0)
  {
    nonlin_fact = "";
    for(i=1; i<=k; i++)
    {
      if(nonlin[2][i]>1)
        {nonlin_fact = nonlin_fact + "(" + string(nonlin[1][i]) + ")^" + string(nonlin[2][i]) + "*";}
      else
        {nonlin_fact = nonlin_fact + "(" + string(nonlin[1][i]) + ")*";}
    }
    nonlin_fact = nonlin_fact[1,size(nonlin_fact)-1];
    dec = "1/(" + nonlin_fact + ") * (" + dec + ")";
  }
  write(":w "+to_dir+"result_"+filename+".txt", dec);

  dec = getStringpfd_indexed(result);
  ideal q = result[1];
  int nq = size(q);
  for(i=1; i<=k; i++)
  {
    q[nq+i] = nonlin[1][i];
  }
  if(k>0)
  {
    nonlin_fact = "";
    for(i=1; i<=k; i++)
    {
      if(nonlin[2][i]>1)
        {nonlin_fact = nonlin_fact + "q" + string(i+nq) + "^" + string(nonlin[2][i]) + "*";}
      else
        {nonlin_fact = nonlin_fact + "q" + string(i+nq) + "*";}
    }
    nonlin_fact = nonlin_fact[1,size(nonlin_fact)-1];
    dec = "1/(" + nonlin_fact + ") * (" + dec + ")";
  }
  write(":w "+to_dir+"result_indexed_"+filename+".txt", dec);
  string denom_fact;
  for(i=1; i<=size(q); i++)
  {
    denom_fact = denom_fact + "q" + string(i) + " = " + string(q[i]) + "%n";
  }
  fprintf(":w "+to_dir+"result_denominator_factors_"+filename+".txt", denom_fact,0);

  write(":w "+to_dir+"resources_"+filename+".txt",sprintf("Time: %s ms,  Memory: %s Bytes",t,memory(2)));
}


proc pfdSingleEntrySSI(string filename, list #)
"USAGE:   pfdSingleEntry(filename[,from_dir,to_dir]), filename,from_dir,to_dir string
PURPOSE:  like pfdSingleEntry, but only the input ssi-files are created!
          The actual pfd calculation is done by pfdSingleEntry
SEE ALSO: pfdMat
"
{
  system("--ticks-per-sec",1000);
  short = 0;
  if(size(#)>0)
  {
    string from_dir = #[1]; // read file from this
    if(from_dir[size(from_dir)]!="/") {from_dir = from_dir + "/";}
  }
  else {string from_dir = "";}
  if(size(#)>1)
  {
    string to_dir = #[2];
    if(to_dir[size(to_dir)]!="/") {to_dir = to_dir + "/";}
  }
  else {string to_dir = "";}

  int i,j,k;
  list fraction;
  i = find(filename,".");
  if(i>0) {filename = filename[1,i-1];} // remove file ending if given

  if(!file_exists(from_dir+filename+".ssi"))
  {
    string s = read(":r "+from_dir+filename+".txt");
    string s1,s2;
    j = find(s,"/(");
    if(j==0) // no denominator
    {
      fraction = list(string_to_poly(s), poly(1));
    }
    else
    {
      s1 = s[1,j-1];
      s2 = s[j+1,size(s)-j];
      fraction = list(string_to_poly(s1), string_to_poly(s2));
    }

    list fact = factorize(fraction[2]);

    number lcoeff;
    number constant = number(fact[1][1])^fact[2][1];
    fact[1] = delete(fact[1],1);
    fact[2] = delete(fact[2],1);
    for(k=1; k<=size(fact[1]); k++)
    {
      lcoeff = leadcoef(fact[1][k]);
      fact[1][k] = fact[1][k]/lcoeff;
      constant = constant*(lcoeff^fact[2][k]); // polynomial is monic (thus unique)
      lcoeff = content(fact[1][k]);
      fact[1][k] = fact[1][k]/lcoeff;
      constant = constant*(lcoeff^fact[2][k]); // polynomial has nice coefficients
    }

    fraction[1] = fraction[1] * (1/constant);
    fraction[2] = fact;

    write("ssi:w "+to_dir+filename+".ssi", fraction);
  }

  list nonlin = list(list(),list());
  i = 1;
  for(k=1; k<=size(fraction[2][1]); k++) // move nonlinear factors into nonlin
  {
    if(deg(fraction[2][1][k])>1)
    {
      nonlin[1][i] = fraction[2][1][k];
      nonlin[2][i] = fraction[2][2][k];
      fraction[2][1] = delete(fraction[2][1],k);
      fraction[2][2] = delete(fraction[2][2],k);
      i++;
    }
  }
}
